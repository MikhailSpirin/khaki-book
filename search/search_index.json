{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":""},{"location":"#what-is-here","title":"What is here","text":"<p>I'm growing my own digital garden here.</p> <p>Concept is simple: as a human being, i gain knowledge everyday - on my work, in my projects, in my spare time hobbies and such. I'm tired to have it on thousands of text files and paper notes. I will put my knowledge in a form of articles in wiki-style site, which now contains my human treasure.</p> <p>In the event of my unfortunate death, send your deepest condolences and read this site - my knowledge will not disappear and i will send my message to those who want to read. If that's the case - i'm really excited!</p> <p>My topics are extremely vast, but let's say its mostly about coding, music creation, generative art, electronics, media and such stuff.</p>"},{"location":"#why-not-blog","title":"Why not blog?","text":"<p>I do love the idea. I have bunch of different files, notes, todoist account, physical papers; to have blog - you need to select a topic, and how to organise papers?</p> <p>This option i'm digging much better. Wiki format is great for tree of knowledge, which i'm going to feed.</p> <p>Cheers!</p>"},{"location":"coding/atom-shortcuts/","title":"Atom Shortcuts","text":"<p>Taken from here - thanks!</p>"},{"location":"coding/atom-shortcuts/#atom-keyboard-shortcuts","title":"Atom Keyboard Shortcuts","text":"<p>This page lists keyboard shortcuts for the Atom text editor that I find valuable and use a lot. Feel free to fork the page and add your own favorites. Pull Requests welcome!</p> <p>This list is by no means meant to be a complete listing of every available shortcut. It simply lists the shortcuts that I use on a regular basis. For a complete listing of all available shortcuts, consult the Settings &gt; Keybindings page in Atom.</p> <p>Since I'm using a Mac, I have mainly listed the keyboard shortcuts macOS. Please feel free to add the Windows or Linux shortcuts.</p> <p>Where the shortcut is provided by a package, I have added a link to the package.</p>"},{"location":"coding/atom-shortcuts/#general","title":"General","text":"<p>Some general keyboard shortcuts that I use frequently.</p> Command macOS Windows Linux Description Preferences/Settings cmd, ctrl, ctrl, Opens the Preferences/Settings view Command Palette shiftcmdp shiftctrlp ctrlshiftp Opens &amp; closes the command palette Open File (Fuzzy) cmdp or cmdt ctrlp or ctrlt ctrlp or ctrlt Opens the Fuzzy Finder palette in which you can search and open files Browse Open Files cmdb ctrlb ctrlb Browse tabs within the window Previous Tab altcmdleft ctrlpageup ctrlpageup Cycles left through open tabs (in the active pane) Next Tab altcmdright ctrlpagedown ctrlpagedown Cycles right through open tabs (in the active page) Grammar Selector ctrlshiftl ctrlshiftl ctrlshiftl Selects the language the file is in Markdown Preview ctrlshiftm ctrlshiftm ctrlshiftm Previews the file in the Markdown format Key Binding Resolver cmd. ctrl. ctrl. Shows what keybindings the pressed key combination resolves to Toggle Tree View cmdk cmdborcmd\\ ctrlk ctrlborctrl\\ ctrlk ctrlborctrl\\ Toggles Atom's file Tree View Reload Atom ctrlaltcmdl altctrlr altctrlr Reloads the Editor Open Link ctrlshifto Opens up a HTTP or HTTPS link Toggle Developer Tools altcmdi ctrlalti ctrlshifti Opens up the Chrome Developer Tools/Console Show Available Snippets altshifts altshifts altshifts Shows the snippets available to Atom"},{"location":"coding/atom-shortcuts/#window-management","title":"Window Management","text":"Command macOS Windows Linux Description New File cmdn ctrln ctrln Opens an empty file in a new tab New Window shiftcmdn ctrlshiftn ctrlshiftn Opens a new editor window Open cmdo ctrlo ctrlo Shows the Open File dialog, which lets you select a file to open in the editor Open Folder cmdshifto ctrlshifto ctrlshifto Shows the Open Folder dialog, which lets you select a folder to add to the editor's Tree View Save cmds ctrls ctrls Saves the currently active file Save As shiftcmds ctrlshifts ctrlshifts Saves the currently active file under a different name Save All altcmds Saves all changed files Close Tab cmdw ctrlw ctrlw Closes the currently active tab Close Window shiftcmdw ctrlshiftw ctrlshiftw Closes the currently active editor window Split Window cmdk \u2191/\u2193/\u2190/\u2192 ctrlk \u2191/\u2193/\u2190/\u2192 ctrlk \u2191/\u2193/\u2190/\u2192 Split the currently active tab in one of the four directions Focus Pane cmdk cmd\u2191/\u2193/\u2190/\u2192 ctrlk ctrl\u2191/\u2193/\u2190/\u2192 ctrlk ctrl\u2191/\u2193/\u2190/\u2192 Move the focus to the pane in one of the four directions Toggle full screen ctrlcmdf F11 F11 Toggle full screen window"},{"location":"coding/atom-shortcuts/#editing","title":"Editing","text":"Command macOS Windows Linux Description Duplicate Lines shiftcmdd ctrlshiftd ctrlshiftd Duplicates the line of the current cursor position and creates a new line under it with the same contents Delete Line ctrlshiftk ctrlshiftk ctrlshiftk Deletes the current line Move Line Up ctrlcmdup ctrlup ctrlup Moves the contents of the current cursor position up one line. If there is a line above with content, the current lines content will swap with the one above it. Move Line Down ctrlcmddown ctrldown ctrldown Moves the contents of the current cursor position down one line. If there is a line below with content, the line's content will swap with the one below it. Find/Replace cmdf ctrlf ctrlf Opens up the Find/Replace panel Find Next cmdg F3 F3 Toggles forward through the results of the current buffer in the file while the Find/Replace panel is active Find Previous shiftcmdg shiftF3 shiftF3 Toggles backward through the results of the current buffer in the file while the Find/Replace panel is active Find in Project shiftcmdf ctrlshiftf ctrlshiftf Opens the Find in Project Panel Go To Line ctrlg ctrlg ctrlg Opens the Go To Line panel Go To Matching Bracket ctrlm ctrlm ctrlm The cursor goes to the matching top bracket that the cursor is ecapsulated in Select Line cmdl ctrll ctrll Selects the entire line the cursor's current position is in Toggle Comment cmd/ ctrl/ ctrl/ Toggles the selected text into a comment of the current grammar Column Selection ctrlshift\u2191/\u2193 ctrlalt\u2191/\u2193 shiftalt\u2191/\u2193 Allows to select multiple rows, where the same edit will be applied Select Same Words cmdd ctrld ctrld If you select a word, and then hit the key combo for this command, Atom will select the next same word for you. Then you can either type directly (which will replace the old words) or use left or right arrow to append things. Undo Selection cmdu ctrlu ctrlu This undoes the previous selection, like from Select Same Words. Select All The Same Words At Once cmdctrlg altf3 altf3 This shortcut is similar to cmdd/ctrld but it selects all the matching words at once. Show Symbols Palette cmdr ctrlr ctrlr This shortcuts opens a palette that lists all the symbols (or functions) in your current file allowing you to fuzzy search and jump lines. Show auto-completions ctrlspace ctrlspace ctrlspace Show available auto-completions Fold/Unfold sections of code optioncmd[ and optioncmd] ctrlalt[ and ctrlalt] ctrlalt[ and ctrlalt] Fold and Unfold sections of code Fold/Unfold at a specific indentation level cmdk then cmd(0-9) ctrlk then ctrl(0-9) ctrlk then ctrl(0-9) Fold/Unfold at a specific indentation level where the number is the indentation depth"},{"location":"coding/atom-shortcuts/#various-packages","title":"Various Packages","text":"<p>These are some packages I find useful, and their most useful key bindings. A list of my favorite packages can be found here.</p> Command macOS Windows Linux Package Block Travel up/down alt\u2191, alt\u2193 Block Travel Beautify ctrlaltb Beautify Build Project cmdaltb ctrlaltb ctrlaltb Build Expand Abbreviation shiftcmde ctrle ctrle Emmet Git Plus Menu shiftcmdh ctrlshifth ctrlshifth Git Plus Jumpy shiftenter Jumpy Minimap Toggle ctrlk ctrlm Minimap Open File in Browser ctrlaltm Open in Browser Open Project ctrlcmdp altshiftp ctrlaltshiftp Project Manager Sublime Style Column Selection altmouse Sublime Style Column Selection"},{"location":"coding/atom-shortcuts/#apm","title":"apm","text":"<p><code>apm</code> is Atom's package manager, based on Node's <code>npm</code> tool.</p> Command Description <code>apm upgrade</code> Updates all locally installed packages <code>apm upgrade --no-confirm</code> Updates all locally installed packages without asking any questions <code>apm stars --install</code> \u00a0Installs/updates all packages that you have marked as a favorite (starred) in your Atom.io profile <code>apm publish minor</code> If you're developing your own package, run this in the package's directory to publish a new version of the package, increasing the minor version number by one."},{"location":"coding/markdown/","title":"Markdown Cheatsheet","text":"<p>taken from markdown-cheetsheet taken from ma</p>"},{"location":"coding/markdown/#heading-1","title":"Heading 1","text":"<pre><code>Markup :  # Heading 1 #\n\n-OR-\n\nMarkup :  ============= (below H1 text)\n</code></pre>"},{"location":"coding/markdown/#heading-2","title":"Heading 2","text":"<pre><code>Markup :  ## Heading 2 ##\n\n-OR-\n\nMarkup: --------------- (below H2 text)\n</code></pre>"},{"location":"coding/markdown/#heading-3","title":"Heading 3","text":"<pre><code>Markup :  ### Heading 3 ###\n</code></pre>"},{"location":"coding/markdown/#heading-4","title":"Heading 4","text":"<pre><code>Markup :  #### Heading 4 ####\n</code></pre> <p>Common text</p> <pre><code>Markup :  Common text\n</code></pre> <p>Emphasized text</p> <pre><code>Markup :  _Emphasized text_ or *Emphasized text*\n</code></pre> <p>~~Strikethrough text~~</p> <pre><code>Markup :  ~~Strikethrough text~~\n</code></pre> <p>Strong text</p> <pre><code>Markup :  __Strong text__ or **Strong text**\n</code></pre> <p>Strong emphasized text</p> <pre><code>Markup :  ___Strong emphasized text___ or ***Strong emphasized text***\n</code></pre> <p>Named Link and http://www.google.fr/ or http://example.com/</p> <pre><code>Markup :  [Named Link](http://www.google.fr/ \"Named link title\") and http://www.google.fr/ or &lt;http://example.com/&gt;\n</code></pre> <p>heading-1</p> <pre><code>Markup: [heading-1](#heading-1 \"Goto heading-1\")\n</code></pre> <p>Table, like this one :</p> First Header Second Header Content Cell Content Cell Content Cell Content Cell <pre><code>First Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell\n</code></pre> <p>Adding a pipe <code>|</code> in a cell :</p> First Header Second Header Content Cell Content Cell Content Cell | <pre><code>First Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  |  \\|\n</code></pre> <p>Left, right and center aligned table</p> <p>Left aligned Header | Right aligned Header | Center aligned Header | :--- | ---: | :---: Content Cell  | Content Cell | Content Cell Content Cell  | Content Cell | Content Cell</p> <pre><code>Left aligned Header | Right aligned Header | Center aligned Header\n| :--- | ---: | :---:\nContent Cell  | Content Cell | Content Cell\nContent Cell  | Content Cell | Content Cell\n</code></pre> <p><code>code()</code></p> <pre><code>Markup :  `code()`\n</code></pre> <pre><code>    var specificLanguage_code =\n    {\n        \"data\": {\n            \"lookedUpPlatform\": 1,\n            \"query\": \"Kasabian+Test+Transmission\",\n            \"lookedUpItem\": {\n                \"name\": \"Test Transmission\",\n                \"artist\": \"Kasabian\",\n                \"album\": \"Kasabian\",\n                \"picture\": null,\n                \"link\": \"http://open.spotify.com/track/5jhJur5n4fasblLSCOcrTp\"\n            }\n        }\n    }\n</code></pre> <pre><code>Markup : ```javascript\n         ```\n</code></pre> <ul> <li>Bullet list<ul> <li>Nested bullet<ul> <li>Sub-nested bullet etc</li> </ul> </li> </ul> </li> <li>Bullet list item 2</li> </ul> <pre><code> Markup : * Bullet list\n              * Nested bullet\n                  * Sub-nested bullet etc\n          * Bullet list item 2\n\n-OR-\n\n Markup : - Bullet list\n              - Nested bullet\n                  - Sub-nested bullet etc\n          - Bullet list item 2\n</code></pre> <ol> <li>A numbered list<ol> <li>A nested numbered list</li> <li>Which is numbered</li> </ol> </li> <li>Which is numbered</li> </ol> <pre><code> Markup : 1. A numbered list\n              1. A nested numbered list\n              2. Which is numbered\n          2. Which is numbered\n</code></pre> <ul> <li>[ ] An uncompleted task</li> <li>[x] A completed task</li> </ul> <pre><code> Markup : - [ ] An uncompleted task\n          - [x] A completed task\n</code></pre> <ul> <li>[ ] An uncompleted task<ul> <li>[ ] A subtask</li> </ul> </li> </ul> <pre><code> Markup : - [ ] An uncompleted task\n              - [ ] A subtask\n</code></pre> <p>Blockquote</p> <p>Nested blockquote</p> <pre><code>Markup :  &gt; Blockquote\n          &gt;&gt; Nested Blockquote\n</code></pre> <p>Horizontal line :</p> <pre><code>Markup :  - - - -\n</code></pre> <p>Image with alt :</p> <p></p> <pre><code>Markup : ![picture alt](http://via.placeholder.com/200x150 \"Title is optional\")\n</code></pre> <p>Foldable text:</p> Title 1 <p>Content 1 Content 1 Content 1 Content 1 Content 1</p> Title 2 <p>Content 2 Content 2 Content 2 Content 2 Content 2</p> <pre><code>Markup : &lt;details&gt;\n           &lt;summary&gt;Title 1&lt;/summary&gt;\n           &lt;p&gt;Content 1 Content 1 Content 1 Content 1 Content 1&lt;/p&gt;\n         &lt;/details&gt;\n</code></pre> <pre><code>&lt;h3&gt;HTML&lt;/h3&gt;\n&lt;p&gt; Some HTML code here &lt;/p&gt;\n</code></pre> <p>Link to a specific part of the page:</p> <p>Go To TOP</p> <pre><code>Markup : [text goes here](#section_name)\n          section_title&lt;a name=\"section_name\"&gt;&lt;/a&gt;\n</code></pre> <p>Hotkey:</p> <p>\u2318F</p> <p>\u21e7\u2318F</p> <pre><code>Markup : &lt;kbd&gt;\u2318F&lt;/kbd&gt;\n</code></pre> <p>Hotkey list:</p> Key Symbol Option \u2325 Control \u2303 Command \u2318 Shift \u21e7 Caps Lock \u21ea Tab \u21e5 Esc \u238b Power \u233d Return \u21a9 Delete \u232b Up \u2191 Down \u2193 Left \u2190 Right \u2192 <p>Emoji:</p> <p>:exclamation: Use emoji icons to enhance text. :+1:  Look up emoji codes at emoji-cheat-sheet.com</p> <pre><code>Markup : Code appears between colons :EMOJICODE:\n</code></pre>"},{"location":"coding/pip/","title":"Indexes","text":"<p>Q: One-time install with different index</p> <pre><code>pip install -i https://pypi.org/simple pip-tools\n</code></pre> <p>Q: How to change source index? Modify pip.conf. For global settings - ~/.pip/pip.conf, for venv - .venv/pip.conf:</p> <pre><code>[global]\nindex-url = https://pypi.org/simple\n</code></pre>"},{"location":"coding/python-packages/","title":"Python Packages","text":"<p>I will list here packages which i used and found to solve issues, also trying to comment stuff which i had problems with</p>"},{"location":"coding/python-packages/#pillow-pil","title":"Pillow (PIL)","text":""},{"location":"coding/python-packages/#shapely","title":"Shapely","text":""},{"location":"coding/python-packages/#pandas","title":"Pandas","text":""},{"location":"coding/challenge/codewars/","title":"Intro","text":"<p>I have a long story about Codewars, i started it with Java, continued with JS, now im training Python and SQL. For me, its the best source of interesting algorithmic tasks. Return to it time to time...</p>"},{"location":"coding/challenge/codewars/#katas","title":"Katas!","text":""},{"location":"coding/challenge/codewars/#kata-1-vowel-count","title":"Kata 1: Vowel Count","text":"Meta Content Date 2021-03-22 Link https://www.codewars.com/kata/54ff3102c1bad923760001f3/"},{"location":"coding/challenge/codewars/#my-solution","title":"My solution","text":"<p>Return the number (count) of vowels in the given string.</p> <pre><code>function getCount(str) {\n  let vowelsArr = str.match(/[aeiou]/ig)\n  return vowelsArr != null ? vowelsArr.length : 0;\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution","title":"Best another solution","text":"<p>Cool lesson is working with null - this is clever solution:</p> <pre><code>const getCount = (str)=&gt;(str.match(/[aeiou]/ig)||[]).length;\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-2-next-perfect-square","title":"Kata 2: Next Perfect Square","text":"Meta Content Date 2021-03-23 Link https://www.codewars.com/kata/56269eb78ad2e4ced1000013"},{"location":"coding/challenge/codewars/#my-solution_1","title":"My solution","text":"<pre><code>function findNextSquare(sq) {\n  let base = Math.sqrt(sq);\n  return base % 1 != 0 ? -1 : (base+1)*(base+1);\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-3-camel-case","title":"Kata 3: Camel Case","text":"Meta Content Date 2021-03-24 Link https://www.codewars.com/kata/517abf86da9663f1d2000003"},{"location":"coding/challenge/codewars/#my-solution_2","title":"My solution","text":"<pre><code>function toCamelCase(str){\n  return str.split(/[-_]/).map((x,i) =&gt; i==0 ? x : x.charAt(0).toUpperCase() + x.slice(1)).join(\"\")\n}\n</code></pre> <p>Main problem here for me was: * several separators for split (now it know i can use regexp in split(re)) * to exclude first character. Solved with checking index, but i think better way may be is to use reduce. But i didn't find how to do it... Example of something similar is here:</p> <pre><code>var products = [{ Name: 'milk', price: 2.50, Category: 'groceries' }, { Name: 'shirt', price: 10, Category: 'clothing' }, { Name: 'apples', price: 5, Category: 'groceries' }],\n    categories = products.reduce(function (r, a) {\n        if (!~r.indexOf(a.Category)) {\n            r.push(a.Category);\n        }\n        return r;\n    }, []);\n</code></pre> <p>// this solution is also cool, based completely on regexps. Didn't know i can use function in replace:</p> <pre><code>function toCamelCase(str){\n      var regExp=/[-_]\\w/ig;\n      return str.replace(regExp,function(match){\n            return match.charAt(1).toUpperCase();\n       });\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-4-trailing-zeros","title":"Kata 4: Trailing Zeros","text":"Meta Content Date 2021-04-23 Link https://www.codewars.com/kata/52f787eb172a8b4ae1000a34/train/javascript"},{"location":"coding/challenge/codewars/#my-solution_3","title":"My solution","text":"<pre><code>function zeros (n) {\n  let factors5 = []\n  let num = 1;\n  do\n    factors5 = [...factors5, num *=5];\n  while (num&lt;n);\n  return factors5.reduce((counter, item)=&gt; counter += Math.floor(n / item), 0)\n}\n</code></pre> <p>Very cool cata, but its pure math, its not that much dev here. I tried 3 approaches - first generate array of digits and then delete all except 2,5 and 0. Too big array. 12s timeout/ 2nd approach was - find how many terms i have - of 2 and 5 and 0. Works with big problem,failed after 100 (because of 25) Solved it only by finding solutioon outside - that we have anough factors 2, so we need only how much 5s, 25s, 125s we have there Overengineered, generated array of factors5 and then reduce on it</p>"},{"location":"coding/challenge/codewars/#best-another-solution_1","title":"Best another solution","text":"<pre><code>function zeros (n) {\n  var zs = 0;\n  while(n&gt;0){\n    n=Math.floor(n/5);\n    zs+=n\n  }\n  return zs;\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-5-decode-morse","title":"Kata 5 Decode Morse","text":"Meta Content Date 2021-03-29 Link https://www.codewars.com/kata/54b724efac3d5402db00065e"},{"location":"coding/challenge/codewars/#my-solution_4","title":"My solution","text":"<pre><code>decodeMorse = function(morseCode){\n  return morseCode.split(\"   \").map(word=&gt;word.split(\" \").map(ch=&gt;MORSE_CODE[ch]).join(\"\")).join(\" \").trim();\n}\n</code></pre> <p>Problem is internal map. I guess for best practices, it would be much better if i had an internal function for decoding separate letters - much readable, and i found such solution at 1st place among best practices</p>"},{"location":"coding/challenge/codewars/#best-another-solution_2","title":"Best another solution","text":"<pre><code>decodeMorse = function(morseCode){\n  return morseCode\n    .trim()\n    .split(/  | /)\n    .map( (code) =&gt; MORSE_CODE[code] || ' ')\n    .join('');\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-6-grandmother-walk","title":"Kata 6 Grandmother Walk","text":"Meta Content Date 2021-03-31 Link"},{"location":"coding/challenge/codewars/#my-solution_5","title":"My solution","text":"<pre><code>function isValidWalk(walk) {\n  return walk.length == 10 &amp;&amp;\n    walk.filter(x=&gt;x=='n').length-walk.filter(x=&gt;x=='s').length == 0 &amp;&amp;\n    walk.filter(x=&gt;x=='e').length-walk.filter(x=&gt;x=='w').length == 0 ? true : false;\n}\n</code></pre> <p>// First tried to solve it via reducing array - using its items as commands // then went for some coffee and understand that there is no sense in it, //i can isolate each separate dimension and just count its ++ and --. // So task is 3 conditions now and became very simple.</p> <p>// No other solutions today, i didn't find anything interesting. //Maybe, counting commands could be extracted to separate function</p>"},{"location":"coding/challenge/codewars/#kata-7-break-camelcase","title":"Kata 7: Break Camelcase","text":"Meta Content Date 2021-04-01 Link https://www.codewars.com/kata/5208f99aee097e6552000148"},{"location":"coding/challenge/codewars/#my-solution_6","title":"My solution","text":"<pre><code>function solution(string) {\n    return string.split(\"\")\n      .reduce((acc,c)=&gt; c.toLowerCase()!=c ? acc+\" \"+c : acc+c, \"\")\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution_3","title":"Best another solution","text":"<p>I know i know its regexp. Capturing groups, lookahead probably and $1 $2. But i wanted to train reduce, its the only higher order function, which i don't \"feel\" yet. But i definitely feel its very powerful.</p> <p>Solution came suprisingly fast, i just had to remember how to return acc. BTW, correct namings helped, need to remember this - use acc, curr, i, arr - this helps to wrtie \"return\" statement accordingly.</p>"},{"location":"coding/challenge/codewars/#kata-8-rule-of-divisibility-by-13","title":"Kata 8 Rule of divisibility by 13","text":"Meta Content Date 2021-04-03 Link https://www.codewars.com/kata/564057bc348c7200bd0000ff"},{"location":"coding/challenge/codewars/#my-solution_7","title":"My solution","text":"<pre><code>let seq=[1,10,9,12,3,4];\n\nfunction thirt(n) {\n  let nNew = n.toString().split(\"\").reverse().reduce((acc,curr,index)=&gt;{\n    return acc += +curr*seq[index % 6];\n   }, 0);\n  if (n == nNew) return n;\n  else {    \n    return thirt(nNew);\n  }\n}\n</code></pre> <p>Here i really liked my idea about seq[index % 6]. Task is to apply some fixed sequence to long list of didgits (i don't know what is length of this list). I just take all seprate digits and apply element of sequence with index % 6. Need to remember this approach...+++</p>"},{"location":"coding/challenge/codewars/#kata-9-common-denominator","title":"Kata 9 Common Denominator","text":"Meta Content Date 2021-04-04 Link https://www.codewars.com/kata/54d7660d2daf68c619000d95"},{"location":"coding/challenge/codewars/#my-solution_8","title":"My solution","text":"<pre><code>function convertFrac(lst){\n  const lcm = (a,b) =&gt; a/gcd(a,b)*b;\n  const gcd = (a,b) =&gt; b==0 ? a : gcd (b, a % b);\n  let commonDenom = lst.map(x=&gt;x[1]).reduce((acc,curr)=&gt;lcm(acc,curr), 1);\n  return lst.reduce((acc,curr)=&gt; `${acc}(${curr[0]*commonDenom / curr[1]},${commonDenom})`,\"\")\n}\n</code></pre> <p>I'm very proud of my reduce usage, its very cool in this case. Also it was interesting to try again gcd recursion. I hope i will remember algorithm once. At least i remember gcd/lcm terms.</p>"},{"location":"coding/challenge/codewars/#kata-10-sum-maximum-subarray","title":"Kata 10 Sum Maximum Subarray","text":"Meta Content Date 2021-04-04 Link https://www.codewars.com/kata/54521e9ec8e60bc4de000d6c"},{"location":"coding/challenge/codewars/#my-solution_9","title":"My solution","text":"<pre><code>var maxSequence = function(arr){\n  let bestSum = 0;\n  return arr.reduce((acc, curr)=&gt;{\n    bestSum = (bestSum + curr &gt; curr) ? bestSum + curr : curr;\n    return (acc &gt; bestSum) ? acc : bestSum\n  },0)\n}\n</code></pre> <p>This is another algorytm - Kadane Algorytm, which i have no chance to come up with)) So i just read about it it in wiki and created my understood version of it</p> <p>nothing that clever in other solutions tho</p>"},{"location":"coding/challenge/codewars/#kata-12-multiply-n-primes","title":"Kata 12: Multiply N Primes","text":"Meta Content Date 2021-04-06 Link"},{"location":"coding/challenge/codewars/#my-solution_10","title":"My solution","text":"<pre><code>function numPrimorial(n){\n  const findPrimes = (lim) =&gt; {\n    let arr = Array(lim).fill(true);\n    arr[0]=arr[1]=false;\n    for (let i=2; i&lt;=Math.sqrt(lim); i++)\n      if (arr[i] == true) for (j=i*i; j&lt;lim; j+=i)\n        arr[j] = false;  \n    return arr.reduce((out, bool, i) =&gt; bool ? out.concat(i) : out, [] );\n  }\n  primes=[];\n  for (i=n; primes.length &lt; n; i*=2) primes = findPrimes(i);\n  return primes.slice(0,n).reduce((acc,curr) =&gt; acc *= curr, 1)\n}\n</code></pre> <p>I hope i will finally remember Sieve of Eratosthenes algorytm. Each time.. This is very logical question on any interview, i must remember it</p> <p>Another problem - i know it can be optimized, because i calculate array or primes each time</p>"},{"location":"coding/challenge/codewars/#kata-13-decomposing-factorial","title":"Kata 13: Decomposing Factorial","text":"Meta Content Date 2021-04-08 Link"},{"location":"coding/challenge/codewars/#my-solution_11","title":"My solution","text":"<pre><code>function decomp(n) {\n  const subDecomp = (num,dividers) =&gt; {\n    let rem = num;\n    for (let i=2; i&lt;=Math.sqrt(num); i++) {\n      if (rem % i === 0){\n        if (!dividers[i]) dividers[i] = 0;\n        while (rem % i === 0){\n          dividers[i]++;\n          rem /= i;\n        }\n      }\n    }\n    if (rem &gt; 1)\n      dividers[rem] = !dividers[rem] ? 1 :dividers[rem]+1;\n    return dividers;\n  }\n  divs = {};\n  for (let i=2; i&lt;=n; i++){\n    divs=subDecomp(i,divs);\n    }\n  return Object.keys(divs).map(x=&gt;divs[x] == 1 ? x : `${x}^${divs[x]}`).join(' * ');\n}\n</code></pre> <p>my first attempt took me too far. I should reduce usage of reduce and stop generating arrays all the time -</p> <p>it didn't pass random tests due to time of execution.. of course, there are very many divisions</p> <p>and i cheated for original solution.. found idea on different site...</p>"},{"location":"coding/challenge/codewars/#best-another-solution_4","title":"Best another solution","text":"<pre><code>function getPrimes(n) {\n  let lim = Math.sqrt(n);\n  let numbers = Array(n+1).fill().map((_,i)=&gt;i);\n  numbers[0] = numbers[1]=0;\n  for (i=2; i&lt;lim; i++)\n    for (j=i*2; j&lt;numbers.length; j+=i)\n      numbers[j]=0;\n  return numbers.filter(i=&gt;!!i)\n}\n\nfunction getDivs(n,primes) {\n  //console.log(primes);\n  return primes.reduce((acc,curr)=&gt;{\n    let divs = [];\n    while (n % curr == 0 &amp;&amp; n &gt;= curr){\n      n /= curr;\n      divs = [...divs, curr];\n    }\n    return [...acc,...divs];\n  },[])\n}\n\nfunction decomp(n) {\n  let primes = getPrimes(n);\n  let divs = Array(n+1).fill().map((_,i)=&gt;i).filter(i=&gt;i &gt;= 2)\n      .reduce((acc,curr)=&gt;[...acc, ...getDivs(curr,primes)],[])\n      .reduce(function(acc, curr) {\n          acc[curr] = (acc[curr] || 0) + 1;\n          return acc;\n      }, {});\n  return Object.keys(divs).map(x=&gt;divs[x] == 1 ? x : `${x}^${divs[x]}`).join(' * ');\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-14-difference-between-arrays","title":"Kata 14: Difference Between Arrays\"","text":"Meta Content Date 2021-04-08 Link https://www.codewars.com/kata/523f5d21c841566fde000009"},{"location":"coding/challenge/codewars/#my-solution_12","title":"My solution","text":"<pre><code>function arrayDiff(a, b) {\n  return a.reduce((acc, curr) =&gt; b.indexOf(curr) == -1 ? [...acc, curr] : acc, []);\n}\n</code></pre> <p>thought it is very clever until i saw this one:</p>"},{"location":"coding/challenge/codewars/#best-another-solution_5","title":"Best another solution","text":"<pre><code>function array_diff(a, b) {\n  return a.filter(e =&gt; !b.includes(e));\n}\n</code></pre> <p>i forgot about filter...</p>"},{"location":"coding/challenge/codewars/#kata-15-word-of-a10n","title":"Kata 15: Word of A10n\"","text":"Meta Content Date 2021-04-10 Link https://www.codewars.com/kata/5375f921003bf62192000746"},{"location":"coding/challenge/codewars/#my-solution_13","title":"My solution","text":"<pre><code>const abbreviate = (string) =&gt; string.replace(/\\w+/gim,\n        (s)=&gt;s.length&lt;4 ? s : `${s.slice(0,1)}${s.length-2}${s.slice(s.length-1)}`);\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution_6","title":"Best another solution","text":"<p>Oneliner - which i do like. Cool that my solution is actually almost exactly \"best practices\" + \"clever\" solution.</p>"},{"location":"coding/challenge/codewars/#kata-16-count-presses","title":"Kata 16: Count Presses\"","text":"Meta Content Date 2021-04-11 Link https://www.codewars.com/kata/54a2e93b22d236498400134b"},{"location":"coding/challenge/codewars/#my-solution_14","title":"My solution","text":"<pre><code>function presses(phrase) {\n  let combi = ['1', 'ABC2', 'DEF3', 'GHI4', 'JKL5', 'MNO6', 'PQRS7', 'TUV8', 'WXYZ9', '*', ' 0', '#' ];\n  return phrase.toUpperCase().split(\"\").reduce((acc, curr)=&gt;{\n    let word = combi.filter(i=&gt;i.includes(curr))[0];\n    return acc+word.indexOf(curr)+1;\n  },0);\n}\n</code></pre> <p>Very important in this kata for my POV - how to make it simple and effective, so that in real life you can give it diffreent keyboard layouts</p> <p>But now i think that simples solution might be better - just additional helper to transform layouts to number of presses and store object with \"symbol\":\"number of presses\"</p>"},{"location":"coding/challenge/codewars/#kata-17-longest-palindrome","title":"Kata 17: Longest Palindrome","text":"Meta Content Date 2021-04-12 Link"},{"location":"coding/challenge/codewars/#my-solution_15","title":"My solution","text":"<pre><code>longestPalindrome=function(s){\n  const checkIfPalindrome = (arr) =&gt; arr.join(\"\") == arr.reverse().join(\"\")\n  const findMaxPalindrome = (acc,c,ind,arr)=&gt; {    \n    let maxP = \"\";\n    //check case of odd length palindrome\n    let j=1;\n    let tryP = c;\n    while((ind-j)&gt;=0 &amp;&amp; (ind+j)&lt;=arr.length) {\n      tryP = [arr[ind-j], ...tryP, arr[ind+j]];\n      if (checkIfPalindrome(tryP) &amp;&amp; tryP.length &gt; maxP.length) {\n        maxP = tryP.join(\"\");\n      } else break;\n      j++;\n    }\n\n    j=1;\n    tryP = [c, arr[ind+1]];\n    while((ind-j)&gt;=0 &amp;&amp; (ind+j+1) &lt;= arr.length) {\n      tryP = [arr[ind-j], ...tryP, arr[ind+j+1]];\n      if (checkIfPalindrome(tryP) &amp;&amp; tryP.length &gt; maxP.length) {\n        maxP = tryP.join(\"\");\n      } else break;\n      j++;\n    }\n    if (checkIfPalindrome(tryP) &amp;&amp; tryP.length &gt; maxP.length)\n      maxP = tryP.join(\"\");    \n    if (!maxP) {\n      maxP = c;\n    }\n    return acc.length &lt; maxP.length ? maxP : acc;\n  }\n\n   return s.split(\"\").reduce(findMaxPalindrome,[]).length;\n}\n</code></pre> <p>that was really tough for me, as i couldn't find small cool algorytm for this. Except bruteforce, only idea which i thought of is check all symbols and check if to both forward and backward it has palindrome. Complexity looks like O(n2) My silution has a lot to enhance, but i can't come up with good enhancements Anyway, as o understand, there is only 1 algorytm which is simpler - manaker algorytm Also not sure, but maybe approach which is called dynamic programming could be better than mine</p> <p>by far - the most complicated task for me</p>"},{"location":"coding/challenge/codewars/#kata-18-statistics","title":"Kata 18: Statistics","text":"Meta Content Date 2021-04-13 Link"},{"location":"coding/challenge/codewars/#my-solution_16","title":"My solution","text":"<pre><code>const convToMS = (i) =&gt; {\n  let t = i.split(\"|\");\n  return new Date(1970,1,1,t[0],t[1],t[2]).getTime()\n}\nconst convToDate = (i) =&gt; {\n  let t = new Date(i)\n  return `${zero(t.getHours())}|${zero(t.getMinutes())}|${zero(t.getSeconds())}`\n}\nconst zero = (i) =&gt; i &lt; 10 ? `0${i}` : i;\nconst stat = (strg) =&gt; {\n  if (!strg) return \"\";\n  let tMS = strg.split(\", \").map(convToMS).sort((a,b)=&gt;a-b);\n  let len = tMS.length;\n  let range = tMS[len-1] - tMS[0];\n  let average = tMS.reduce((a,b) =&gt; a+b,0) / len;\n  let median = len % 2 == 0 ? (tMS[len/2] + tMS[len/2-1]) / 2: tMS[(len-1)/2];\n  return `Range: ${convToDate(range)} Average: ${convToDate(average)} Median: ${convToDate(median)}`      \n}\n</code></pre> <p>Basically that wasn't complicated - string manipulation, main task here for me was to do it clean and readable Training \"team point of view\" when writing a code I see no cooler solutions than mine</p> <p>Just one additional comment - here i tried to split functionality in different functions, as i try to do clean and pure functions No modification of global vars, no complex actions - just one straigntforwad action</p>"},{"location":"coding/challenge/codewars/#kata-19-number-to-word","title":"Kata 19 Number to Word","text":"Meta Content Date 2021-04-14 Link"},{"location":"coding/challenge/codewars/#my-solution_17","title":"My solution","text":"<pre><code>function number2words(n, result = \"\"){\n  const d = {\n    0:\"zero\", 1:\"one\", 2:\"two\", 3:\"three\", 4: \"four\", 5:\"five\", 6:\"six\", 7:\"seven\", 8:\"eight\", 9:\"nine\",\n    10:\"ten\", 11:\"eleven\", 12:\"twelve\", 13:\"thirteen\", 14:\"fourteen\", 15:\"fifteen\",\n    16:\"sixteen\", 17:\"seventeen\", 18:\"eighteen\", 19:\"nineteen\",\n    20:\"twenty\",30:\"thirty\",40:\"forty\",50:\"fifty\",60:\"sixty\",70:\"seventy\",80:\"eighty\",90:\"ninety\",\n  }\n    switch (true) {\n        case (n&lt;=20 || n==30 || n==40 || n==50 || n==60 || n==70 || n==80 || n==90) :\n          result = `${result}${d[n]}`; break;\n        case (n&gt;20 &amp;&amp; n&lt;100):\n          result = `${d[n-n%10]}-${d[n%10]}`; break;\n        case (n%100 == 0 &amp;&amp; n&lt;1000):\n          result = `${d[Math.round(n/100)]} hundred`; break;\n        case (n&gt;=100 &amp;&amp; n&lt;1000):\n          result = `${d[Math.floor(n/100)]} hundred ${number2words(n%100, result)}`;break;\n        case (n%1000 == 0 &amp;&amp; n&lt;10000):\n          result = `${d[Math.floor(n/1000)]} thousand`; break;\n        case (n&gt;=1000 &amp;&amp; n&lt;999999):\n          result = `${number2words(Math.floor(n/1000), result)} thousand ${number2words(n%1000, result)}`;break;\n    }\n  return result;// works for numbers between 0 and 999999   \n}\n</code></pre> <p>// This task taught me that i really can use recursion in real life, and take this decision naturally. My solution is not perfect, // i see that i added to many conditions - seems that can be done only with 3. But this is MINE solution)</p> <p>// Probably after refactor i could approach this best solution. This is just a lot of ternary checks + now i see that // i don't need object in this task</p>"},{"location":"coding/challenge/codewars/#best-another-solution_7","title":"Best another solution","text":"<pre><code>function number2words(n){\n    // works for numbers between 0 and 999999\n    var b=[\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\",\"eleven\",\"twelve\",\"thirteen\",\"fourteen\",\"fifteen\",\"sixteen\",\"seventeen\",\"eighteen\",\"nineteen\"];\n    var b2=[\"twenty\",\"thirty\",\"forty\",\"fifty\",\"sixty\",\"seventy\",\"eighty\",\"ninety\"]\n    if(n&gt;=0 &amp;&amp; n&lt;20){\n      return b[n];\n    }\n    if(n &gt;= 20 &amp;&amp; n&lt;100){\n      return b2[Math.floor(n/10)-2]+(n%10===0?'':'-'+b[n%10])\n    }\n    if(n&gt;=100 &amp;&amp; n&lt;1000){\n      return b[Math.floor(n/100)]+' hundred'+(n%100===0?'':' '+number2words(n%100));\n    }else{\n      return number2words(Math.floor(n/1000))+' thousand'+(n%1000===0?'':' '+number2words(n%1000));\n    }\n  }\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-21-reverse-or-rotate","title":"Kata 21: Reverse or rotate?","text":"Meta Content Date 2021-04-16 Link https://www.codewars.com/kata/56b5afb4ed1f6d5fb0000991/"},{"location":"coding/challenge/codewars/#my-solution_18","title":"My solution","text":"<pre><code>function revrot(str, sz) {\n  const isSumCubesDivsBy2 = (i) =&gt; i.reduce((acc,curr)=&gt;acc+(+curr)**3, 0) % 2 == 0;\n  let res=[];\n  if (sz==0) return \"\";\n  for (let i=0; i&lt;=str.length; i+=sz)\n       res.push(str.slice(i,i+sz).split(\"\"));\n  if (res[res.length-1].length&lt;sz) res=res.slice(0,res.length-1);\n  return res.map(i=&gt;{\n    return isSumCubesDivsBy2(i) ? i.reverse().join(\"\") : [...i.slice(1), i[0]].join(\"\")\n  }).join(\"\")\n}\n</code></pre> <p>I solved the problem, but in comparison to best answer i see that i don't have enough experience (yet) about organizing code. This thing with 3 const functions looks and reads wonderful. Code in solution below is clean and clear. Mine is spaghetti in comparison, but i will try to improve. Also i see that i named function wrong here...</p>"},{"location":"coding/challenge/codewars/#best-different-solution","title":"Best different solution","text":"<pre><code>function revrot(str, sz) {\n  if (sz &lt; 1 || sz &gt; str.length)\n    return '';\n\n  let reverse = s =&gt; s.split('').reverse().join('');\n  let rotate  = s =&gt; s.slice(1) + s.slice(0, 1);\n  let sum_cubes = c =&gt; c.split('').reduce((a, b) =&gt; a + +b ** 3, 0);\n\n  return str\n    .match(new RegExp('.{' + sz + '}', 'g'))\n    .map(c =&gt; sum_cubes(c) % 2 ? rotate(c) : reverse(c))\n    .join('');\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-22-sorting-liquids","title":"Kata 22: Sorting liquids","text":"Meta Content Date 2021-04-17 Link https://www.codewars.com/kata/562e6df5cf2d3908ad00019e/solutions/javascript"},{"location":"coding/challenge/codewars/#my-solution_19","title":"My solution","text":"<pre><code>function separateLiquids(glass) {   /// glass[V][H]\n  const density = {\n    H : 1.36,\n    W : 1.00,\n    A : 0.87,\n    O : 0.80\n  }\n  const chunkArray = (arr, size) =&gt;\n  arr.length &gt; size\n    ? [arr.slice(0, size), ...chunkArray(arr.slice(size), size)]\n    : [arr];\n  const srt = (a,b) =&gt; density[a] == density[b] ? 0 : (density[a] &gt; density[b] ? 1 : -1)\n\n  if (!glass.length) return [];\n  return chunkArray(glass.reduce((a,b)=&gt;[...a, ...b]).sort(srt), glass[0].length)\n}\n</code></pre> <p>This is really cool kata. Thing is you go through several stages here, from first assumptions to first complicatetd atom conditions to final simple and very cool solution Before i understand that we have \"left\" direction and this could mean we just need to sort flat array, i spend some time on trying to get what kinds of limits we have here.</p> <p>Spend some time on thinking about edge cases... Like</p> <pre><code>00++\n++++\n+111\n</code></pre> <p>But, after checking tests it turned out that this exact solution was expected. And all is good.</p> <p>Also caught something new from other solutions:</p>"},{"location":"coding/challenge/codewars/#best-different-solution_1","title":"Best different solution","text":"<pre><code>const density = { H: 1.36, W: 1, A: .87, O: .8 };  \n\nconst separateLiquids = glass =&gt;\n  [].concat(...glass)\n    .sort((a, b) =&gt; density[a] - density[b])\n    .reduce((arr, v, i) =&gt; {\n      if (!(i % glass[0].length)) arr.push([]);\n      arr[arr.length - 1].push(v);\n      return arr;\n    }, []);\n</code></pre> <p>Cool thing here is sorting function, which i realy like and didn't come up with by myself.</p>"},{"location":"coding/challenge/codewars/#kata-23-meeting","title":"Kata 23: Meeting","text":"Meta Content Date 2021-04-20 Link https://www.codewars.com/kata/59df2f8f08c6cec835000012"},{"location":"coding/challenge/codewars/#my-solution_20","title":"My solution","text":"<pre><code>const srt = (a,b) =&gt;{\n  [anew,bnew] = [a.split(\":\"), b.split(\":\")];\n  return (anew[1] == bnew[1]) ? anew[0].localeCompare(bnew[0]) : anew[1].localeCompare(bnew[1])\n}\nconst meeting = (s) =&gt; {\n  let res = s.toUpperCase().split(\";\").sort(srt)\n      .reduce((acc,cur)=&gt;{\n        let names=cur.split(\":\");\n        return `${acc}(${names[1]}, ${names[0]})`\n      },\"\")\n  return res;\n}\n</code></pre> <p>It was very interesting to solve this problem, as path is very straightforward, but im not that good in splitting main task into simple ones; in this case i managed to do this without any issues.</p> <p>And then...</p>"},{"location":"coding/challenge/codewars/#best-another-solution_8","title":"Best another solution","text":"<pre><code>function meeting(s) {\n  let string = s.toUpperCase().split(';')\n                .map(x =&gt; x.split(':').reverse().join(', '))\n                .sort()\n                .join(')(')\n  return '(' + string + ')'\n}\n</code></pre> <p>I must have checked if sort works or not for this case without additional things. Looks like it works</p>"},{"location":"coding/challenge/codewars/#kata-24-stonks","title":"Kata 24: Stonks","text":"Meta Content Date 2021-04-21 Link https://www.codewars.com/kata/597ef546ee48603f7a000057"},{"location":"coding/challenge/codewars/#my-solution_21","title":"My solution","text":"<pre><code>const count_sum = (arr)=&gt;arr.reduce((a,b)=&gt;a+b,0)\n\nfunction getMostProfitFromStockQuotes(quotes) {\n  let max = Math.max(...quotes);\n  let income_arr = quotes.slice(0, quotes.indexOf(max));\n  let income = max * income_arr.length - count_sum(income_arr);\n  if (income &lt; 0) income = 0;\n  let left = quotes.slice(quotes.indexOf(max)+1);\n  return (left.length == 0) ? income  :\n    income + getMostProfitFromStockQuotes(left);\n}\n</code></pre> <p>Main problem here was to understand the logic behind the task. At first i didn't get how results in tests are evaluated. First assumtion was to evaluate array of max profits from existing stocks - like [sum(what_is_before), maxitem], then select maximum. Next step was - understanding that it will need recursive behavior, because after first sell there might be another sells also. So i spent some time on setting up recursion for this. Next, result didn't align with tests) BTW, i thought there are (may be) better strategy... But no, my result was lower than in tests. Then i understood algorytm (which is just find max on current array, count income, repeat on all array which is to the right from current max)</p> <p>Cool kata, interesting if there is any algorythm</p>"},{"location":"coding/challenge/codewars/#best-another-solution_9","title":"Best another solution","text":"<p>Absolute brilliant soltuion, day will come and i will understand logic behind it</p> <pre><code>function getMostProfitFromStockQuotes(quotes) {\n  let top=-Infinity;\n  return quotes.reduceRight((p,v)=&gt;{\n    if(top&lt;v) top=v;\n    return p+top-v;\n  }, 0);\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-25-matching-and-substituting","title":"Kata 25 Matching and Substituting","text":"Meta Content Date 2021-04-23 Link https://www.codewars.com/kata/59de1e2fe50813a046000124/"},{"location":"coding/challenge/codewars/#my-solution_22","title":"My solution","text":"<pre><code>function change(s, prog, version) {\n  let prog_regex = /(?&lt;=Program).*\\n/gm;\n  let author_regex = /(?&lt;=Author: ).*\\n/gm;\n  let phone_regex = /(?&lt;=Phone: ).*\\n/gm\n  let valid_phone_regex = /\\+1-\\d{3}-\\d{3}-\\d{4}\\n/gm\n  let corp_regex = /Corporation: .*\\n/gm;\n  let date_regex = /(?&lt;=Date: )(.*)\\n/gm;\n  let vers_regex = /(?&lt;=Version: ).*\\n/gm;\n  let valid_vers_regex = /(?&lt;=Version: )\\d+\\.\\d+\\n/gm\n  let level_regex = /Level: .*/gm;\n\n  return !(valid_phone_regex.test(s) &amp;&amp; valid_vers_regex.test(s)) ? \"ERROR: VERSION or PHONE\" :\n     s.replace(prog_regex, `: ${prog} `)\n      .replace(author_regex, `g964 `)\n      .replace(corp_regex, ``)\n      .replace(phone_regex, `+1-503-555-0090 `)\n      .replace(date_regex, \"2019-01-01 \")\n      .replace(vers_regex, (match) =&gt; match == 2.0 ? \"2.0\" : version)\n      .replace(level_regex, \"\")\n}\n</code></pre> <p>Ok there are several lessons under this kata.</p> <ul> <li>Positive/negative lookaheads/lookbehinds are cool. Spent some time learning them. Very cool</li> <li>Capturing groups - last time i was far less effective with them.</li> <li>Orginizing code: this time i decided to make this template-task self explanatory and clean</li> </ul> <p>These were straightforward lessons. Less stright is something veri interesting - you shouldn't do kata before fully understanding COMPLETE description. Also, this kata shows that actually transforming original task description can make work much easier. Its fun because this is exactly what i learned as part of software development process... First you always tring to understand if the task should be SO complicated. Usually its actually not.</p>"},{"location":"coding/challenge/codewars/#best-another-solution_10","title":"Best another solution","text":"<pre><code>function change(s, prog, version) {\n\n  if (/Version: 2.0\\n/.test(s))\n    version = '2.0';\n\n  if (!/Phone: (\\+1-\\d{3}-\\d{3}-\\d{4})\\n/.test(s) || !/Version: \\d+\\.\\d+\\n/.test(s))\n    return 'ERROR: VERSION or PHONE';\n\n  return `Program: ${prog} Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: ${version}`;\n\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-26-dont-eat-last-cake","title":"Kata 26: Dont Eat Last Cake","text":"Meta Content Date 2021-04-24T13:46:33+03:00 Link"},{"location":"coding/challenge/codewars/#my-solution_23","title":"My solution","text":"<pre><code>// Constructor (your Captain Obivious)\nfunction Player(){}\n// Decide who move first - player or opponent (true if player)\n\nconst winning = (i) =&gt; {\n  let left = (i - 2) % 4;\n  return (left == 0) ? 0 : left;\n}\n\nPlayer.prototype.firstmove = function(cakes){\n  if (cakes==1) return false;\n  if (cakes==2) return false;\n  return (winning(cakes) == 0) ? false : true;\n}\n// Decide your next move\nPlayer.prototype.move = function(cakes, last){\n  let left = winning(cakes);\n  if (last == 0) return left;\n\n  //obvious moves\n  if (cakes==3 &amp;&amp; last!=1) return 1;\n   if (cakes==4 &amp;&amp; last!=3) return 3;\n   if (cakes==5 &amp;&amp; last !=3) return 3;\n\n  if (left == 3 &amp;&amp; last == 1) return 3;  \n  if (left == 2 &amp;&amp; last == 2) return 1;\n  if (left == 1 &amp;&amp; last == 3) return 1;\n\n    //sub cases of 2:2\n  if (left == 3 &amp;&amp; last == 2) return 3;\n  if (left == 2 &amp;&amp; last == 3) return 2;\n}\n</code></pre> <p>This was by far most complicated one. I didn't manage to solve it in one day, started trying to find pattern and similar games. Actually i determined correct connected algorithm - https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem But, all described games were actually games without abanoded \"same move\". I dind't manage to understand how to turn this into mex function which is described by that theorem... Finally i decided just to get it from logic and completely analyzed games with n&lt;14. It helped to determin algorythm. Some time was spend on understanding how to do \"series\" of steps in reaction of opponent goinf out from loosing position.</p> <p>Interesting that in this case</p> <p>I will definitely read more about that theorem. BTW, i need to re-read math books from my childhood. I really think i will find something interesting there - mainly by Gardner.</p>"},{"location":"coding/challenge/codewars/#best-another-solution_11","title":"Best another solution","text":""},{"location":"coding/challenge/codewars/#kata-27-backspaces-processing","title":"Kata 27 Backspaces Processing","text":"Meta Content Date 2021-04-25 Link https://www.codewars.com/kata/5727bb0fe81185ae62000ae3/"},{"location":"coding/challenge/codewars/#my-solution_24","title":"My solution","text":"<pre><code>function cleanString(s) {\n      return s.split(\"\")\n        .reduce((acc,curr)=&gt;curr == \"#\" ? acc.slice(0,-1) : `${acc}${curr}`,\"\")\n};\n</code></pre> <p>This was cool and simple. Clear example of reduce usage. Can't come up with something simpler.</p>"},{"location":"coding/challenge/codewars/#best-another-solution_12","title":"Best another solution","text":"<p>Strange, but crowd thinks that push/pop solution is better. Its a mistake. Mine or their...</p>"},{"location":"coding/challenge/codewars/#kata-28-how-much","title":"Kata 28: How Much","text":"Meta Content Date 2021-04-26 Link https://www.codewars.com/kata/55b4d87a3766d9873a0000d4"},{"location":"coding/challenge/codewars/#my-solution_25","title":"My solution","text":"<p>Ok so 6th level for me now is usually not more than 20 mins. I should use it only if know that i will not have a chance to work on bigger kata today.</p> <p>This was simple.. Just needed some math googling</p> <pre><code>function howmuch(m, n) {\n    if (m&gt;n) [m,n] = [n,m];\n    let arr = [];\n    for (let x = m; x&lt;=n; x++)\n      if ((x-1)%9==0 &amp;&amp; (x-2)%7==0)\n        arr = [...arr,[`M: ${x}`,`B: ${(x-2)/7}`,`C: ${(x-1)/9}`]]    \n    return arr;\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution_13","title":"Best another solution","text":"<p>Ok so this is better solution, had to think how to get max better...</p> <pre><code>function howmuch(m, n) {\n  let out = [], h = Math.max(m, n);\n  for(let i = Math.max(Math.min(m, n), 37); i &lt;= h; i++) {\n    //This is the stupidest data \"structure\" I've ever seen\n    if((i - 1) % 9 == 0 &amp;&amp; (i - 2) % 7 == 0) out.push([`M: ${i}`, `B: ${(i - 2) / 7}`, `C: ${(i - 1) / 9}`]);\n  }\n  return out;\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-29-lazy-evaluation","title":"Kata 29 Lazy Evaluation","text":"Meta Content Date 2021-04-28 Link"},{"location":"coding/challenge/codewars/#my-solution_26","title":"My solution","text":"<pre><code>function Lazy() {\n  let functions = [];\n  let obj = {\n    add(...args) {\n      functions.push(args);\n      return this;\n    },\n    invoke(target) {\n      return functions\n        .reduce((acc, cur)=&gt; cur[0].apply(null, [...cur.slice(1), ...acc]),target)\n    }\n  }\n  return obj;\n}\n</code></pre> <p>Finally! This is what expected when people say \"functional programming\". Very-very cool kata, not as complicted algorytm, but about managing functions. Was very interesting. Found half of solution by request \"how to chain functions\", but i had problems with understanding how to pass function with arguments to the list. Solution was to store all of it - like array of [function, ...args] in internal array of functions. Cool! Want to do such tasks more</p> <p>Oh and i forgot about constructor. But.. there was no init procedure, so probably that's fine.</p>"},{"location":"coding/challenge/codewars/#best-another-solution_14","title":"Best another solution","text":"<pre><code>class Lazy {\n  constructor() {\n    this.fnChain = [];\n  }\n  add(fn, ...args) {\n    this.fnChain.push(fn.bind(this, ...args));\n    return this;\n  }\n  invoke(args) {\n    return this.fnChain.reduce((args, fn) =&gt; fn(...args), args);\n  }\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-30-advanced-pig-latin","title":"Kata 30: Advanced Pig Latin","text":"Meta Content Date 2021-04-29 Link"},{"location":"coding/challenge/codewars/#my-solution_27","title":"My solution","text":"<pre><code>function piggify(w) {\n  let isCapital = w[0] === w[0].toUpperCase();\n  let regex = /(^[b-df-hj-np-tv-z]*)([aeoui]\\w*)(\\W*)/;\n  let piggified = w.toLowerCase().replace(regex, (_,p1,p2,p3)=&gt;{\n    return (p1.length==0) ? `${p2}way${p3}` : `${p2}${p1}ay${p3}`\n  })\n   return isCapital ? `${piggified[0].toUpperCase()}${piggified.slice(1)}` : piggified\n}\nfunction translate(sentence) {\n  return sentence.split(\" \").map(piggify).join(\" \");\n};\n</code></pre> <p>Look i spent some time trying to avoid regexp here) But soon understood that this adds ineviteable complexity. Thing is its manipulating chunks of string - exactly regexp is probably the best fit.</p>"},{"location":"coding/challenge/codewars/#best-another-solution_15","title":"Best another solution","text":"<p>Looks like i didn't think of 2 things - first that i don't necessarly need to split whole sentence into words, it would work without this redundant function. Second is - i don't need 3 groups! Punctuation just stays same as before. So i need only 1st and 2nd group to solve this. Also isCapital may be is redundant, but i used it to make code more readable.</p> <p>Also if conditions - not sure i understand thin line between when to use ternary operator and when i can't use it</p> <pre><code>function translate(sentence) {\n  return sentence.replace(/\\b([bcdfghjklmnpqrstvwxyz]*)(\\w+)\\b/gi, function(_, first, rest) {\n    if (first) {\n      if (first[0] == first[0].toUpperCase()) rest = rest[0].toUpperCase() + rest.slice(1)\n    } else {\n      first = 'w'\n    }\n    return rest + first.toLowerCase() + 'ay'\n  })\n};\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-31-new-holiday","title":"Kata 31: New Holiday","text":"Meta Content Date 2021-05-06 Link https://www.codewars.com/kata/58982a388927f70d8b000111/"},{"location":"coding/challenge/codewars/#my-solution_28","title":"My solution","text":"<pre><code>function holiday(x, weekDay, month, yearNumber) {\n  const months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n  const leapyear = ((yearNumber % 100 === 0) ? ( yearNumber % 400 === 0) : (yearNumber % 4 === 0));\n  const daysinmonths = [31,  leapyear ? 29 : 28 , 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\n  let firstday = (new Date(`${month} 1, ${yearNumber}`)).getDay();\n  let daysnormalized = [...days.slice(firstday), ...days.slice(0, firstday)];\n  let dmax = daysinmonths[months.indexOf(month)];\n  let d = (x-1)*7 + daysnormalized.indexOf(weekDay) + 1;\n  return d &gt; dmax ? -1 : d\n}\n</code></pre> <p>Kewl! Spent some time trying to understand how to start it. My idea is to get weekday for 1st of given year/month, then count weeks and some leftover days (between starting day and given day). It was hard to start splitting this task. I suspect all date tasks are problematic like this one</p>"},{"location":"coding/challenge/codewars/#best-another-solution_16","title":"Best another solution","text":"<pre><code>function holiday(x, weekDay, month, yearNumber) {\n\n  const months = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ];\n  const days_of_week = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ];\n\n  const idx_month = months.indexOf(month);\n  const idx_dow = days_of_week.indexOf(weekDay);\n\n  let date = new Date(yearNumber, idx_month, 1);\n\n  if (date.getDay() &gt; idx_dow)\n    x++;\n\n  date.setDate(date.getDate() + idx_dow - date.getDay() + 7 * (x - 1));\n\n  return date.getMonth() === idx_month ? date.getDate() : -1;\n\n}\n</code></pre> <p>Cool thing here is solving leap year problem, i subsituted 29/28 based on counting what is given year, but in this example its done by just getting if we're still in current month or moved to next (it's based on internal js Date mechanizms). This is probably better approach than mine...</p>"},{"location":"coding/challenge/codewars/#kata-32-string-incrementer","title":"Kata 32 String Incrementer","text":"Meta Content Date 2021-05-14 Link https://www.codewars.com/kata/54a91a4883a7de5d7800009c/"},{"location":"coding/challenge/codewars/#my-solution_29","title":"My solution","text":"<pre><code>const inc_zeros = (n) =&gt; {\n  let r = `${+n+1}`;\n  while (r.length&lt;n.length)\n    r = `0${r}`;\n  return r\n}\n\nfunction incrementString (strng) {\n  return strng.replace(/(\\D*)(\\d*$)/, (_,p1,p2,offset,s) =&gt; {\n     console.log(p1,p2);\n     if (p2.length == 0) return `${p1}1`;\n     if (p2.length == p2.replace(/^0+/, '').length) return `${p1}${+p2+1}`\n      else return `${p1}${inc_zeros(p2)}`;\n   } );\n}\n</code></pre> <p>It was hard kata for me, because i didn't manage to find beautiful solution. I feel like mine is bad, but i cant figure out what to refactor. Checking best solutions....</p>"},{"location":"coding/challenge/codewars/#best-another-solution_17","title":"Best another solution","text":"<pre><code>function incrementString(input) {\n  if(isNaN(parseInt(input[input.length - 1]))) return input + '1';\n  return input.replace(/(0*)([0-9]+$)/, function(match, p1, p2) {\n    var up = parseInt(p2) + 1;\n    return up.toString().length &gt; p2.length ? p1.slice(0, -1) + up : p1 + up;\n  });\n}\n</code></pre> <p>This is very clever usage of regexps:</p> <pre><code>function incrementString(input) {\n  return input.replace(/([0-8]?)(9*)$/, function(s, d, ns) {\n      return +d + 1 + ns.replace(/9/g, '0');\n    });\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-33-simple-fun-best-match","title":"Kata 33 Simple Fun Best Match","text":"Meta Content Date 2021-05-15 Link"},{"location":"coding/challenge/codewars/#my-solution_30","title":"My solution","text":"<pre><code>function bestMatch(ALAHLYGoals, zamalekGoals) {\n  const srt = (a,b)=&gt;{\n    if (a[0]==b[0] &amp;&amp; a[1]&gt;b[1]) return -1;\n    if (a[0]==b[0] &amp;&amp; a[1]&lt;b[1]) return 1;\n    if (a[0]==b[0] &amp;&amp; a[1]==b[1] &amp;&amp; a[2]&gt;b[2]) return 1;\n    if (a[0]==b[0] &amp;&amp; a[1]==b[1] &amp;&amp; a[2]&lt;b[2]) return -1;\n    return a[0]&gt;b[0] ? 1 : -1;\n  }\n  return zamalekGoals.map((e,i)=&gt;[ALAHLYGoals[i]-e, e, i]).sort(srt)[0][2];\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution_18","title":"Best another solution","text":"<pre><code>function bestMatch(aGoals, bGoals) {\n   return bGoals\n     .reduce((best, goals, i) =&gt; {\n       const diff = aGoals[i] - goals;\n       return !best.d || (diff &lt; best.d || (diff === best.d &amp;&amp; goals &gt; best.v)) ? {d: diff, v: goals, i} : best;\n      }, {d: null, g: null, i: null}).i;\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-34-sort-strings-vowels","title":"Kata 34 Sort Strings Vowels","text":"Meta Content Date 2021-05-16 Link https://www.codewars.com/kata/5d2d0d34bceae80027bffddb"},{"location":"coding/challenge/codewars/#my-solution_31","title":"My solution","text":"<pre><code>const srt = (a,b) =&gt; {\n   if (a.length == b.length) return 0;\n   return a.length &gt; b.length ? -1 : 1            \n  }\n\nconst longestsubstr = (e) =&gt; (e.match(/[aeiouAEIOU]+/gm) || []).sort(srt)[0];\n\nfunction sortStringsByVowels(strings){\n  return strings.sort((a,b) =&gt; srt((longestsubstr(a) || []),(longestsubstr(b) || [])));\n}\n</code></pre> <p>Well i think my solution is clearer) definitely i must have refactored my sorting function. But im really happy i managed to get the general approach. Also i think it's not 6, its definitely 5 kyu...</p>"},{"location":"coding/challenge/codewars/#best-another-solution_19","title":"Best another solution","text":"<pre><code>function sortStringsByVowels(ss) {\n  const gl=s=&gt;(Math.max(...(s.match(/[aeiou]+/ig)||[]).map(r=&gt;r.length)))\n  return ss.sort((a,b)=&gt;gl(b)-gl(a));\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-35-snake-collision","title":"Kata 35 Snake Collision","text":"Meta Content Date 2021-05-18 Link"},{"location":"coding/challenge/codewars/#my-solution_32","title":"My solution","text":"<p>https://www.codewars.com/kata/5ac616ccbc72620a6a000096/solutions/javascript</p> <pre><code>function snakeCollision(g, m){\n  let snake = [[0, 0],[0, 1],[0, 2]];\n  let d = \"R\";\n  let steps = 0;\n\n  const isFood = (cords) =&gt; g[cords[0]][cords[1]]=='$';\n  const isSnake = (cords) =&gt; snake.some((e)=&gt;(e[0]==cords[0] &amp;&amp; e[1]==cords[1]));\n  const isBorder = (cords) =&gt; (cords[0] &lt; 0 || cords[0] &gt;= 13 || cords[1] &lt; 0 || cords[1] &gt;= 21);\n  const head = () =&gt; snake[snake.length-1];\n  const move = (d) =&gt; {\n      let dest;\n\n      switch (d) {\n          case \"D\": dest = [head()[0]+1, head()[1]]; break;\n          case \"R\": dest = [head()[0], head()[1]+1]; break;\n          case \"U\": dest = [head()[0]-1, head()[1]]; break;\n          case \"L\": dest = [head()[0], head()[1]-1]; break;\n      }\n\n      if (isBorder(dest)) return false;\n      if (isSnake(dest)) return false;\n      snake.push(dest);\n\n      if (!isFood(dest))\n        snake.shift();\n      if (isFood(dest))        \n        g[dest[0]] = [...g[dest[0]].slice(0, dest[1]), '-', ...g[dest[0]].slice(dest[1]+1)].join(\"\");   \n      return true;\n  }\n\n  for (const cmd of m.split(\" \")) {\n    if (+cmd == cmd) {\n      let canMove = true;\n      for (let i = 0; i&lt;+cmd; i++) {\n        canMove = move(d);\n        steps++;\n        if (!canMove) return [head(),steps]\n      }  \n    } else d = cmd;\n  }\n  return [head(),steps]\n}\n</code></pre> <p>I actually spend some time on this. Definitely most complicated kata by now, reason is simple - it just has too many limitations which needs to be solved. Problem for me here is the fact that i don't know if i solved it right... I tried to be as clean-coded and straight-forward as possible, but still can't figure oout what can be improved.</p> <p>Im not sure about existence of head() function, and im not that fond of main flow loop... Still im happy i managed to finish it. Cool.</p>"},{"location":"coding/challenge/codewars/#kata-36-merge-strings-checker","title":"Kata 36 Merge Strings Checker","text":"Meta Content Date 2021-05-17 Link https://www.codewars.com/kata/54c9fcad28ec4c6e680011aa"},{"location":"coding/challenge/codewars/#my-solution_33","title":"My solution","text":"<pre><code>function isMerge(s, part1, part2) {\n    const takeFromFirst = (s,arr1,arr2) =&gt; {\n      for (let i in s) {\n        if (s[i]==arr1[i] &amp;&amp; s[i]==arr2[i] ) continue;\n        if (s[i]==arr1[i] &amp;&amp; s[i]!==arr2[i]) return true;\n        if (s[i]!==arr1[i] &amp;&amp; s[i]==arr2[i]) return false;\n      }\n    }\n    let [part1arr, part2arr] = [part1.split(\"\"),\n                                part2.split(\"\")];\n    for (let i in s) {\n      if (s[i] == part1arr[0] &amp;&amp; s[i] == part2arr[0]) {\n        console.log(\"we have very complicated situation here\");\n        if (takeFromFirst(s.slice(i), part1arr, part2arr))\n          part1arr.shift();\n        else\n          part2arr.shift();\n        continue;\n      } else if (s[i] == part1arr[0])\n        part1arr.shift();\n      else if (s[i] == part2arr[0])\n        part2arr.shift();\n      else return false;\n    }  \n    if (part1arr.length&gt;0 || part2arr.length&gt;0) return false;\n    return true;\n}\n</code></pre> <p>Well it was very interesting. I manage to solve it but it ws really tough. I first tried simple and stupid way - sort 1st and concat of test strings. Didn't work like it should be) Then i was in the cross - like what to do next? Try to improve sorting or go different way? I chose second, but still not sure it was right decision. Will spend some time trying to understand best solution.</p> <p>UPD - finally i got it! I should have solved it with recursion... So stupid))</p>"},{"location":"coding/challenge/codewars/#best-another-solution_20","title":"Best another solution","text":"<p>This one i don't understand at all))</p> <pre><code>function isMerge(s, part1, part2) {\n  return !s ? !(part1 || part2) :\n    s[0] == part1[0] &amp;&amp; isMerge(s.slice(1), part1.slice(1), part2) ||\n    s[0] == part2[0] &amp;&amp; isMerge(s.slice(1), part1, part2.slice(1));\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-37-traffic-jam","title":"Kata 37 Traffic Jam","text":"Meta Content Date 2021-05-20 Link https://www.codewars.com/kata/5a26073ce1ce0e3c01000023"},{"location":"coding/challenge/codewars/#my-solution_34","title":"My solution","text":"<pre><code>var trafficJam = function(mainRoad, sideStreets) {\n  let mr = mainRoad.split(\"\");\n  let out = sideStreets.reduceRight((acc,curr,i)=&gt;{\n    if (curr!=\"\") {\n      curr.split(\"\").reverse().forEach((e,ei)=&gt;mr.splice(i+ei*2+1, 0, e));\n      return mr;\n    } else\n      return mr;\n  }, mr);\n  return out.slice(0,mr.indexOf(\"X\")+1).join(\"\");\n}\n</code></pre> <p>That was the most amazing moment in my (not-yet-started) dev career. Really. I spent almost whole day on this kata. Couldn't understand the approach. Tried different ones.</p> <p>Main moment here is when i started to investigate, if all separate side roads addding can be somehow atomic - not like 1 car by 1 car, but whole line of cars.</p> <p>With approach \"pop from every not-empty array\", i couldn't come up with idea how to use reduce; but if we do 1-by-1 side road, reduce will fit.</p> <p>But it didn't work, so i wrote the function, it didn't solve. Also, pattern of generated string was different. So - trying different order, or may be even those insertions can't be atomic?</p> <p>And then i remember that there is reduceRight function, may be it's already available in this env?... And yes and YES!!! All tests passed, except one issue (reverse order of side roads), which i solved a bit later...</p>"},{"location":"coding/challenge/codewars/#best-another-solution_21","title":"Best another solution","text":"<p>in javascript i see no such solution. Mine is most simple and beautiful. )))</p>"},{"location":"coding/challenge/codewars/#kata-38-which-are-in","title":"Kata 38 Which Are In","text":"Meta Content Date 2021-05-21 Link https://www.codewars.com/kata/550554fd08b86f84fe000a58/"},{"location":"coding/challenge/codewars/#my-solution_35","title":"My solution","text":"<pre><code>function inArray(array1,array2){\n  return array1.filter(e =&gt; array2.some(str=&gt;str.indexOf(e) != -1)).sort((a,b)=&gt;a.localeCompare(b))\n}\n</code></pre> <p>Cool, that was really simple)</p>"},{"location":"coding/challenge/codewars/#kata-39-chess-fun-cell-color","title":"Kata 39 Chess Fun Cell Color","text":"Meta Content Date 2021-05-24 Link https://www.codewars.com/kata/5894134c8afa3618c9000146"},{"location":"coding/challenge/codewars/#my-solution_36","title":"My solution","text":"<pre><code>function chessBoardCellColor(cell1, cell2) {\n  const parity = (cell) =&gt; (\"_ABCDEFGH\".indexOf(cell.split(\"\")[0]) + Number(cell.split(\"\")[1])) % 2 == 0;\n  return parity(cell1) === parity(cell2)\n}\n</code></pre> <p>Ok, that was simple. Can't find better solution in solutions.</p>"},{"location":"coding/challenge/codewars/#kata-40-last-survivor-2","title":"Kata 40 Last Survivor 2","text":"Meta Content Date 2021-05-25 Link"},{"location":"coding/challenge/codewars/#my-solution_37","title":"My solution","text":"<pre><code>function lastSurvivors(str) {\n  const hasDuplicates = (arr) =&gt; new Set(arr).size !== arr.length;\n  let str_arr = str.split(\"\").map(x=&gt;x.charCodeAt(0));\n  while (hasDuplicates(str_arr)) {\n    for (const c of str_arr) {\n      [first,last] = [str_arr.indexOf(c), str_arr.lastIndexOf(c)]\n      if (first !== last) {\n        str_arr[first] = (c == 122) ? 97 : str_arr[first] + 1;\n        str_arr.splice(last, 1);\n        break;\n      }        \n    }\n  }\n   return str_arr.map(x=&gt;String.fromCharCode(x)).join(\"\");\n}\n</code></pre> <p>Ok so i spent some time on this. Main problem is that i tried to solve this kata with ES6 abilities - but i failed. Problem is that we need several rimes to look through array - and i can't understand how can i do it with reduce</p> <p>But, obvious refactor, which i found in other best solution - do away with char codes. I could just create an array of lowcase letters and deal with its array indexes - this is clearer and simpler than solution which i used</p> <p>BTW, now i think this whole charcodes is my 2000s legacy) Thats how i solved things in my high school. Now its different times...</p>"},{"location":"coding/challenge/codewars/#best-another-solution_22","title":"Best another solution","text":"<pre><code>function lastSurvivors(str) {\n\n  const alpha = 'abcdefghijklmnopqrstuvwxyz';\n\n  let next = str;\n\n  do {\n    str = next;\n    next = str.replace(/([a-z])(.*?)\\1/g, (_, a, b) =&gt; alpha[(alpha.indexOf(a) + 1) % 26] + b);\n  } while (str !== next)\n\n  return str;\n\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-41-compose-functions-t-combinator","title":"Kata 41 Compose Functions T Combinator","text":"Meta Content Date 2021-05-27 Link https://www.codewars.com/kata/51f9d3db4095e07f130001ee"},{"location":"coding/challenge/codewars/#my-solution_38","title":"My solution","text":"<pre><code>var compose = function(n, ...fns) {\n  return (fns.length == 0) ? n : fns.reduce((acc,curr)=&gt;curr(acc),n);\n}\n</code></pre> <p>Ok so im amaxed how simple and quick i solved this task. Deadly simple for me, as im really get used to using reduce day-to-day. Plus, with ES6 its really simple to cut array-like arguments...</p>"},{"location":"coding/challenge/codewars/#best-another-solution_23","title":"Best another solution","text":"<p>Another way of solving it (didn't thinka about it) is actually using recursion, which is also +- simple to understand, even from desciption of this kata. Cool!</p> <pre><code>const compose = (x, f, ...rest) =&gt; f ? compose(f(x), ...rest) : x;\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-42-sudoku-solver","title":"Kata 42 Sudoku Solver","text":"Meta Content Date 2021-06-09 Link"},{"location":"coding/challenge/codewars/#my-solution_39","title":"My solution","text":"<p>Well that was... fuckingfuck. Very tough for me. Lots of cool moments. And all other things))</p> <pre><code>function sudoku(puzzle) {\n  let gaps = [], solution = [], last = 1, pushed = false;\n  puzzle.forEach((nested,i) =&gt; nested.forEach((item,j) =&gt; {\n    if (item === 0) gaps.push([j,i])\n  }));\n\n  while (solution.length &lt; gaps.length) {\n    let trySolution, x, y;\n    [x,y] = [gaps[solution.length][0], gaps[solution.length][1]];\n    pushed = false;\n    for (let i = last; i &lt;= 9; i++) {\n      trySolution = renderSudoku([...puzzle.map(nested =&gt; [...nested])], gaps, solution, i);\n      if (validateSolution(trySolution)){\n        solution.push(i);\n        pushed = true;\n        break;\n      }\n    }\n    if (!pushed) {\n      if (solution[solution.length - 1] == 9)\n        while (solution[solution.length - 1] == 9) solution.pop();\n      solution[solution.length - 1] += 1;\n    }  \n  }\n  return renderSudoku([...puzzle.map(nested =&gt; [...nested])], gaps, solution, null);\n}\n\nfunction renderSudoku(board, gaps, solution, num){\n  if (num) solution = [...solution, num];\n  solution.forEach((e,i)=&gt;{\n     board[gaps[i][1]][gaps[i][0]] = e;\n  })\n  return board;\n}\n\nfunction validateSolution(board){\n  function isunique(arr) {\n    let filtered = arr.filter(x =&gt; x !== 0);\n    return filtered.every((e,i) =&gt; filtered.indexOf(e) === i);\n  }\n\n  function checkRows(){\n    return board.every(row =&gt; isunique(row));\n  }\n  function checkCols(){\n    return board[0].map((e, i) =&gt; board.map(row =&gt; row[i])).every(col =&gt; isunique(col));\n  }\n  function checkBoxes(){\n    let boxes = [];\n    for (let i = 0; i &lt;= 6; i += 3)\n      for (let j = 0; j &lt;= 6; j += 3)\n        boxes.push([...board[j].slice(i,i+3),\n                    ...board[j+1].slice(i,i+3),\n                    ...board[j+2].slice(i,i+3)]);\n    return boxes.every(box =&gt; isunique(box));\n  }\n  return checkRows() &amp;&amp; checkCols() &amp;&amp; checkBoxes();\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution_24","title":"Best another solution","text":"<p>I will read this at night))) Copyrights to</p> <pre><code>function calculateGridRange(gridNumber) {\n  // summary:\n  //  Calculates the min and max row and column numbers associated\n  //  with a grid number.\n  // gridNumber: Number\n  //  Expects a zero-based number (0-8)\n  // return: Object\n  //  An object containing the min and max row and column numbers.\n  var rowMin = Math.floor(gridNumber / 3) * 3,\n      columnMin = gridNumber % 3 * 3;\n\n  return {\n    row: {\n      min: rowMin,\n      max: rowMin + 2\n    },\n    column: {\n      min: columnMin,\n      max: columnMin + 2\n    }\n  };\n}\n\nfunction calculateGridNumber(row, column) {\n  // summary:\n  //  Calculate the grid number that corresponds\n  //  to the grid in which a row and column pair reside.\n  // row: Number\n  //  Expects a zero-based number (0-8)\n  // column: Number\n  //  Expects a zero-based number (0-8)\n  // return: Number\n  //  The grid number in which this row and column pair reside.\n  return (Math.floor(row / 3) * 3) + Math.floor(column / 3);\n}\n\nfunction parse(puzzle) {\n  // summary:\n  //  Takes a sudoku puzzle and creates a number map based on the\n  //  numbers' locations within the board.  Also provides methods for\n  //  dynamically generating maps.\n  // puzzle: Array[]\n  //  Array of arrays.  Each element in the parent array is a row.\n  //  The index of the element in the parent array, corresponds to\n  //  the row number.\n  //  Each element in a child array is a number in that row, and its\n  //  index corresponds to the column number in which it resides.\n  // return: Object\n  //  Object containing number map, which is a mapping of where every\n  //  number currently resides in the board, contains a method for determining if there are still empty spaces on the board, contains method for retrieving the empty spaces in a grid, and contains a method for retrieving the missing numbers for a grid.\n  // Example:\n  //  Number Map structure.  Example for number \"1\":\n  //  {\n  //    \"1\": {\n  //      \"1\": { // Row number\n  //        \"3\": { // Column number\n  //          rowNumber: 1,\n  //          columnNumber: 3,\n  //          gridNumber: 1\n  //        }\n  //      }\n  //    }\n  //  }\n  var numberMaps = {},\n      row, i, j,\n      number, numberMap,\n      columnMax, map;\n\n  for (i = 0; i &lt; 9; i++) {\n    row = puzzle[i];\n\n    for (j = 0; j &lt; 9; j++) {\n\n      number = row[j];        \n      if (number) {\n        numberMap = numberMaps[number];\n\n        if (!numberMap) {\n          numberMap = numberMaps[number] = {};\n        }\n\n        map = numberMap[i];\n\n        if (!map) {\n          map = numberMap[i] = {};\n        }\n\n        map[j] = {\n          rowNumber: i,\n          columnNumber: j,\n          gridNumber: calculateGridNumber(i, j)\n        };\n\n      }\n    }\n  }\n\n  return {\n    numberMaps: numberMaps,\n    hasEmptySpaces: function () {\n      // summary:\n      //  Determines if there are empty spaces on the entire board.\n      // returns: Boolean\n      var i, j;\n\n      for (i = 0; i &lt; 9; i++) {\n        for (j = 0; j &lt; 9; j++) {\n          if (!puzzle[i][j]) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    getEmptySpacesByGridNumber: function (gridNumber) {\n      // summary:\n      //  Retrieve the empty spaces (spaces filled with the number 0)\n      //  for a provided grid.\n      // gridNumber: Number\n      //  Expects a zero-based number (0-8)\n      // return: Object\n      //  A row/column mapping of empty spaces.\n      var emptySpaces = {},\n          range = calculateGridRange(gridNumber),\n          row = range.row,\n          column = range.column,\n          rowMin = row.min,\n          rowMax = row.max,\n          columnMin = column.min,\n          columnMax = column.max,\n          i, z, space;\n\n      for (i = rowMin; i &lt; rowMax + 1; i++) {\n        for (z = columnMin; z &lt; columnMax + 1; z++) {\n          if (!puzzle[i][z]) {\n\n            space = emptySpaces[i];\n\n            if (!space) {\n              space = emptySpaces[i] = {};\n            }\n\n            space[z] = true;\n          }\n        }\n      }\n\n      return emptySpaces;\n    },\n    getMissingNumbersByGrid: function (gridNumber) {\n      // summary:\n      //  Returns all of the missing numbers for a given grid as\n      //  a concatenated string.\n      // gridNumber: Number\n      //  Expects a zero-based number (0-8)\n      // return: String\n      var range = calculateGridRange(gridNumber),\n          row = range.row,\n          column = range.column,\n          rowMin = row.min,\n          rowMax = row.max,\n          columnMin = column.min,\n          columnMax = column.max,\n          missingNumbers = \"123456789\",\n          i, j;\n\n      for (i = rowMin; i &lt; rowMax + 1; i++) {\n        for (j = columnMin; j &lt; columnMax + 1; j++) {\n          number = puzzle[i][j];\n\n          if (number) {\n            missingNumbers = missingNumbers.replace(number, \"\");\n          }\n        }\n      }\n\n      return missingNumbers;\n    }\n  };\n}\n\nfunction crossHatch(gridNumber, maps, puzzle) {\n  // summary:\n  //  Performs a cross hatch of a number to a grid's empty spaces.\n  //  When a number is already on the board, and its location\n  //  intersects with a row/column in the grid, that grid is removed\n  //  from the available possibilities for placing a number.\n  //  When only one possibility remains for a number, it is placed.\n  //  If more than one possibility exists, the number is skipped.\n  var missingNumbers = maps.getMissingNumbersByGrid(gridNumber).split(\"\"),\n      total = missingNumbers.length,\n      gridRange = calculateGridRange(gridNumber),\n      row = gridRange.row,\n      column = gridRange.column,\n      rowMin = row.min,\n      rowMax = row.max,\n      columnMin = column.min,\n      columnMax = column.max,\n      number, numberMap, i, j, rowMap, rowNumber, map,\n      columnNumber, availableSpaces, availableRows, availableColumns;\n\n  for (i = 0; i &lt; total; i++) {\n    number = missingNumbers[i];\n    numberMap = maps.numberMaps[number];\n    availableSpaces = maps.getEmptySpacesByGridNumber(gridNumber);\n\n    for (rowNumber in numberMap) {\n      rowMap = numberMap[rowNumber];\n\n      if (rowNumber &gt;= rowMin &amp;&amp; rowNumber &lt;= rowMax) {                                                      \n        if (availableSpaces[rowNumber]) {\n          delete availableSpaces[rowNumber];\n        }\n      }\n\n      for (columnNumber in rowMap) {          \n        if (columnNumber &gt;= columnMin &amp;&amp; columnNumber &lt;= columnMax) {\n          for (j = rowMin; j &lt; rowMax + 1; j++) {\n            if (availableSpaces[j]) {\n              delete availableSpaces[j][columnNumber];\n\n              if (!Object.keys(availableSpaces[j]).length) {\n                delete availableSpaces[j];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Converting the keys of the availableSpaces (which will be row numbers where a number can go)\n    // into an array.  We can then check the length of this array to ensure that only one\n    // possibile row exists for this number in a grid.\n    availableRows = Object.keys(availableSpaces);\n    if (availableRows.length === 1) {\n      // Convert the keys of the availableSpaces[availableRows[0]] (which will be the column numbers where\n      // a number can go) into an array.  We can then check the length of this array, to ensure that only one\n      // possible column exists for this number in a grid.  If there is only one possible column, we have\n      // eliminated all other possibilities for this number in this grid, so we can place it.\n      availableColumns = Object.keys(availableSpaces[availableRows[0]]);\n      if (availableColumns.length === 1) {\n        rowNumber = availableRows[0];\n        columnNumber = availableColumns[0];\n\n        // Convert to a true number because the test expects the array to contain only numbers.\n        puzzle[rowNumber][columnNumber] = parseInt(number, 10);\n\n        // Update the number map to include the new location of this placed number.\n        map = numberMap[rowNumber];\n\n        if (!map) {\n          map = numberMap[rowNumber] = {};\n        }\n\n        map[columnNumber] = {\n          rowNumber: availableRows[0],\n          columnNumber: availableColumns[0],\n          gridNumber: gridNumber\n        };\n      }\n    }\n  }\n}\n\nfunction sudoku(puzzle) {\n  // summary:\n  //  Parses the puzzle and begins the solve process.\n  // puzzle: Array[]\n  //  Array of arrays.  Each element in the parent array is a row.\n  //  The index of the element in the parent array, corresponds to\n  //  the row number.\n  //  Each element in a child array is a number in that row, and its\n  //  index corresponds to the column number in which it resides.\n  var maps = parse(puzzle),\n      i = 0;\n\n  while (maps.hasEmptySpaces()) {\n    if (i === 9) {\n      i = 0;\n    }\n\n    crossHatch(i, maps, puzzle);\n    i++;\n  }\n\n  return puzzle;\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#kata-43-sudoku-validator","title":"Kata 43 Sudoku Validator","text":"Meta Content Date 2021-06-09 Link"},{"location":"coding/challenge/codewars/#my-solution_40","title":"My solution","text":"<pre><code>function validSolution(board){\n  function isunique(arr) {\n    let filtered = arr.filter(x =&gt; x !== 0);\n    return filtered.every((e,i) =&gt; filtered.indexOf(e) === i);\n  }\n\n  function checkRows(){\n    return board.every(row =&gt; isunique(row));\n  }\n  function checkCols(){\n    return board[0].map((e, i) =&gt; board.map(row =&gt; row[i])).every(col =&gt; isunique(col));\n  }\n  function checkBoxes(){\n    let boxes = [];\n    for (let i = 0; i &lt;= 6; i += 3)\n      for (let j = 0; j &lt;= 6; j += 3)\n        boxes.push([...board[j].slice(i,i+3),\n                    ...board[j+1].slice(i,i+3),\n                    ...board[j+2].slice(i,i+3)]);\n    return boxes.every(box =&gt; isunique(box));\n  }\n  return checkRows() &amp;&amp; checkCols() &amp;&amp; checkBoxes();\n}\n</code></pre>"},{"location":"coding/challenge/codewars/#best-another-solution_25","title":"Best another solution","text":"<p>Need to check this one - lots of reduce, all as i like</p> <pre><code>function validSolution(board){\n  var validSet = s =&gt; s.size == 9 &amp;&amp; !s.has(0);\n  var rowSet = i =&gt; board[i].reduce((s,v) =&gt; s.add(v), new Set());\n  var columnSet = i =&gt; board.reduce((s,v) =&gt; s.add(v[i]), new Set());\n  var boxSet = ([r,c]) =&gt; board.slice(r,r+3).reduce((s,v) =&gt; v.slice(c,c+3).reduce((s,v) =&gt; s.add(v), s), new Set());\n  var boxCorner = i =&gt; [Math.floor(i / 3) * 3,(i % 3) * 3];\n  for (var i = 0; i &lt; 9; i++)\n    if ( !validSet(rowSet(i)) || !validSet(columnSet(i)) || !validSet(boxSet(boxCorner(i))) )\n      return false;\n  return true;\n}\n</code></pre>"},{"location":"coding/challenge/leetcode/","title":"Intro","text":"<p>Started it and it feels more completed and concentrated than codewars. More tasks regarding algorithms. So,</p>"},{"location":"coding/challenge/leetcode/#dynamic-programming-climbing-stairs","title":"Dynamic Programming - Climbing Stairs","text":"Meta Content Date 2023-03-30T11:40:33+03:00 Link link to task"},{"location":"coding/challenge/leetcode/#my-solution","title":"My solution","text":"<p>This is general dynamic programming problem, which i meet very often. There are modificatioons of course, but this one is most often used i guess</p> <p>Problem is that basic recoursive solution leads to O(n2) time. Because for each node we start recursion again and again... Solutiuon for this is actually caching: base next steps on prvious ones. Stairs list contains solutions for previous number of stairs - which eliminates duplicate calculations.</p> <p>And next step here is to see that actually results of this function is Fibonacci sequence - so move to regular Fibonacci solution</p> <p>And next step is to remember that there are more efficient algorithms to fin Fibonacci numbers</p> <pre><code>def climbStairs(self, n):\n    if n &lt; 3:\n        return n\n\n    stair = [0] * (n + 1)\n    stair[1] = 1\n    stair[2] = 2\n    for i in range(3, n + 1):\n        stair[i] = stair[i - 1] + stair[i - 2]    \n    return stair[n]\n</code></pre>"},{"location":"coding/challenge/leetcode/#max-subarray","title":"Max Subarray","text":"Meta Content Date 2023-03-31T10:31:46+03:00 Link"},{"location":"coding/challenge/leetcode/#problem","title":"Problem","text":"<p>You need to find subarray with maximum sum. Main idea of solutions is this:</p> <p>Bruteforce approach -     - iterate through each element,     - find maximum starting from this element to each of the following 2 loops, both are N at maximum, so - O(n2)</p> <p>Simple and intuitive suggestion can imoprove this complexity to O(n)!</p>"},{"location":"coding/challenge/leetcode/#kadane-algoryhtm","title":"Kadane Algoryhtm","text":"<p>Lets iterate through each element. For each element, local maximum (of all subarrays between index 0 and current) can be achieved by comparison only 2 maxes - [previous subarray, current element] and [current element]. We can definitely say this way, because maximum for [previous subarray] is already solved during previuos iterations! If we know all local maximums for each element, we can determine global maximum, just by comparing local ones</p> <p>So, instead of counting this subarrays maximums again and again, we use our previous siolutions in each new iteration.</p>"},{"location":"coding/challenge/leetcode/#my-solution-kadane-algorythm","title":"My solution - Kadane algorythm","text":"<pre><code>    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        local_max = - float(\"inf\")\n        global_max = - float(\"inf\")\n        for e in nums:\n            local_max = max(e, e + local_max)\n            if global_max &lt; local_max:\n                global_max = local_max\n        return global_max\n</code></pre>"},{"location":"coding/challenge/leetcode/#divide-and-conquer-approach","title":"Divide and Conquer Approach","text":"<p>To solve the problem, generally we need to find 2 numbers - start and end index of maximum subarray. This is what causes O(n x n) in brute-force approach.</p> <p>In this method, for any subarray, we can split it into 2 halves. Max subarray can be:     - either completely in left side,     - or completely in right side,     - or crossing center (index by which we splitted subarray) For 1 and 2, we can just recursively call the same function. For last one, main advantage of this is that we can split this point into to: left and right, and we KNOW end point for left max and start point for right one - and the we just sum those 2 maxes - and it will be maximum of subarray, cerossing center line. Because we know this start/end point, task of finding left edge and right edge is linear (maximum (n/2 + n/2) if max_subarray == array). Complexity of this soultion is O(n x log(n)). log(n) part is recoursive dividing (same as binary search). n part is linear search of local maximum for subarray, which crosses center.</p> <p>It is worse than Kadane algoerythm, but it gives an approach which can be used in different algorythms.</p>"},{"location":"coding/challenge/leetcode/#my-soultion-divide-and-conquer","title":"My soultion - Divide and Conquer","text":"<p>def maxSubArray(self, nums):     \"\"\"     :type nums: List[int]     :rtype: int     \"\"\"     if len(nums) == 1:         return nums[0]</p> <pre><code>middle_index = len(nums) // 2\nleft_max = self.maxSubArray(nums[:middle_index])\nright_max =  self.maxSubArray(nums[middle_index:])\n\nlocal_max_left = -float(\"inf\")\nacc1 = 0\nfor i in range(middle_index-1, -1, -1):\n    acc1 += nums[i]\n    if acc1 &gt; local_max_left:\n        local_max_left = acc1\n\nlocal_max_right = -float(\"inf\")\nacc2 = 0\nfor i in range(middle_index, len(nums), 1):\n    acc2 += nums[i]\n    if acc2 &gt; local_max_right:\n        local_max_right = acc2\n\ncrossing_center_max = local_max_left + local_max_right\nreturn max(left_max, right_max, crossing_center_max)\n</code></pre>"},{"location":"coding/challenge/leetcode/#dynamic-programming-robber","title":"Dynamic Programming - Robber","text":"<pre><code>Meta | Content\n-----|-----------\nDate | 2023-04-04T13:51:02+03:00\nLink | [link to task](https://leetcode.com/explore/interview/card/top-interview-questions-easy/97/dynamic-programming/576/)\n</code></pre>"},{"location":"coding/challenge/leetcode/#my-solution_1","title":"My solution","text":"<pre><code>Basically, i struggled how to solve such problems without knowing actual algorythm. You can do bruteforce, of course; but definitely, this is not optimal and really ugly solution. In this case, basic recoursive bruteforce is actually O(2n)!!\n\nGreat approach which i found is described here, according to this specific task:\n[here](https://leetcode.com/problems/house-robber/solutions/156523/From-good-to-great.-How-to-approach-most-of-DP-problems)\n\nWe start with basic recursive, than try dynamic approach - store what is calculated in map, then eliminate recursive, than optimise storage. Will this one in next tasks!\n</code></pre> <pre><code>    class Solution(object):  \n        def rob(self, nums):\n            \"\"\"\n            :type nums: List[int]\n            :rtype: int\n            \"\"\"\n            memo = [0] * (len(nums)+1)\n            print(len(memo), len(nums))\n\n            if not len(nums):\n                return 0\n            if len(nums) == 1:\n                return nums[0]\n\n            memo[0] = 0\n            memo[1] = nums[0]\n            for i in range(len(nums)):\n                memo[i+1] = max(memo[i-1] + nums[i], memo[i])\n                print(memo)\n\n            return memo[i+1]\n</code></pre>"},{"location":"electronics/repair/dp003sd/","title":"Tascam DP-003SD","text":""},{"location":"electronics/repair/dp003sd/#pre","title":"Pre","text":"<p>That is probably the most complicated and big item which i repaired in whole electronics career. And im really-really happy with the result!</p> <p>Internally it consists of 3 different boards - digital part, analog interfaces to outside world and \"controls\" board - sliding and rotarry pots, displa etc. It's packed firmly inside, so i had hard time disassembling and assembling it back - lots of effort and only photos of the whole process helped me to put it altogether while assembling.</p> <p> </p>"},{"location":"electronics/repair/dp003sd/#problem","title":"Problem","text":"<p>Device turned on, but no sound in headphones + glitches and accidental turn-off. Disassembling showed that something sticky was spoiled on control board... It dried long before, but traces of white grey and green in all types you can imagine showed that it was something with sugar!</p> <p>Anyway, i had to completely clean all foil from elelectromagnetic shields first, i spend some time recreating foil loayer on plasting and cutting it all the same way it was there before. </p> <p>Happy accident was the fact that digital board was not affected at all; though, i had to replace some rusty linear and regular pots on control board.</p>"},{"location":"electronics/repair/dp003sd/#phones","title":"Phones","text":"<p>After assembling everything, headphones still not working completely. I traced whole signal path from jack to DAC - all worked fine; but, acidentally found out that dac to didgtal to analog board connector didn't ring! So i found that - due to rust, board trace was broked specifically at through-board connection. after Recreating with solder all worked perfectly well.</p> <p></p> <p>Amazing experience, 60 usd for device which costs 200+ usually - i'm very glad with this specific fix and will use it to record my modular</p>"},{"location":"electronics/repair/microverb/","title":"Alesis Microverb 2","text":"<p>Had this for a while, bought without power supply. Ordered one and check - LED whorks ugly, loud crackles and hisses when moving pots, definitely worth changing it first. Allrighty, lets open it.</p>"},{"location":"electronics/repair/microverb/#visual","title":"Visual","text":"<p>I like the complexity colors, quality of build, everything about this board. Says 1986, assebled in Korea - and loots amazingly cool. But lets start. After some visual inspection, i also decded to change all electrolitic capacitors due to its age: fourty years straight</p> <p></p> <p>Cool! My first capacitor boom. I still have no idea why, but power capacitor bursted (replaced one). Polarity is correct, capacity and voltage is the same. Weird, but seems that old japan ones are a bit better in terms of holding correct voltage. Replaced with 50v instead of 25v.</p> <p>Also replaced potentiometers. Due to different shaft, i had to change original pot caps. Bad but it worth it, because</p>"},{"location":"electronics/repair/microverb/#it-works","title":"It works","text":"<p>No issues, works like a charm. Sound is a bit weired, because its probably one of the first-generation digital delays - it is so much stuff on board! Several opamps, logic, DSP, EEPROM - a lot of things. Anyway, cool unit and interesting sound.</p>"},{"location":"electronics/repair/quadvca/","title":"AI Synthesis Quad VCA Mixer","text":"<p>Amazing AI Synthesis creates simple, beginner-friendly, beautiful modules and DIY kits which are thoroughly documented and well-designed. I assembled several of those some time before, and now it was time for their most complicated product - Quad VCA, which is completely smd and quite dense.</p> <p></p> <p>Actually it is a fix. I assebled module a year ago and didnt manage to successfully run it. Didn't have enough experience with smd to reflow it - so it appeared in the shelf. Now, with my new abilities and ideas, i finally decided to fix it. </p>"},{"location":"electronics/repair/quadvca/#problem","title":"Problem","text":"<p>This is it: dense smd board, 6 ics (4 tl074 and 2 SSI2164, which are actually VCAs). I started by reflowing all ics. It's much simpler to do that using rose alloy - i find this method easiest. I have a fan but i all the time worried about burning ics with it..</p> <p>Anyway, this didn't help. So i started to check other components and i find... That i ordered and soldered 14 510kOhm resistors instead of 510Ohm ones. What a shame. I found my order in mail - yes, i did that mistake at order stage. most of resistors were asy to desolder, but part of them... I had to desolder some jacks...</p>"},{"location":"electronics/repair/quadvca/#conclusion","title":"Conclusion","text":"<p>It is really easy to make mistake anywhere, and really had no idea what to check next, especially if board is big and dense. Check it! Especially with smd, which can be hard to desolder. Check nominals!</p> <p></p>"},{"location":"electronics/repair/samplingmodulator/","title":"Befaco Sampling Modulator","text":"<p>Oh how much months i spent on tracing and checking of this module.. Almost everything worked fine except for little problem with external clock mode - it didn't worked.</p> <p>Resoldered tiny smd transistor pair under opamp bed with new one. Then, found out that it's legs doesnt ring as they shoud; as schematic shows me. I even added small wire and.. Checked one more time and understood that i misread ic number, so i tried to solve non-existing problem. Removed that trace and checked all again...</p> <p>And...</p> <p>Sorry, don't have photo, but that pain which i had there - worth adding this post.</p> <p>Fiunally, all is working well. This 1-year problem finally resoled. Very satisfying!</p>"},{"location":"electronics/repair/strymonaa1/","title":"Strymon Aa.1 repair. First Post!","text":"<p>This will be my first post. I really-really enjoy electronics. It is something magical in process of fixing and building all those electronics things. As I am a musician and long-time-obsessed-with-music-guy, this type of work is a perfect match for me. So,</p>"},{"location":"electronics/repair/strymonaa1/#broken-stuff-visual-inspection","title":"Broken stuff - visual inspection","text":"<p>One of input jacks is definitely broken. It is not regular one,  so i tried to find subsittute- and yes! I found it locally. So replacing it.</p> <p>Was a simple task, using braid and solder sucker. Butm, when turned on, i nmoticed that top part of module is not working completely.   </p>"},{"location":"electronics/repair/strymonaa1/#broken-top-part","title":"Broken top part","text":"<p>Analyzed with DMM - see no action on ouputs at all. Next one was an op-amp, simple TL072. And yes, seems that is exactly the problem here - P-N juctions are shorted, according to diode mode on my DMM. Desoldering it and replacing with general style SOIC TL072.</p> <p>I used general IC check technique - check diode junctions, like here</p> <p>Working perfectly!</p> <p></p>"},{"location":"electronics/repair/strymonaa1/#conclusion","title":"Conclusion","text":"<p>I'm very satisfied with my first commercial-style fix (it's not my own module, and i was paid for this job which is amazing!). Simple but successful one.</p>"},{"location":"electronics/repair/tides/","title":"Jakkplugg Tides 2018","text":"<p>Two issues here: first, module was not burned, so i spent some time digging into MI dev environment setting up and firmware uploading process; went well of course.</p> <p> </p> <p>Another small issue which i traced using schematic (thanks to ancient gods people adding schematic to those smd pcb reworks): one trace was cut just in the middle of its path. Weird, but this is probably quality of pcb.</p> <p>Anyway - added piece of wire to solve this issue and all works amazingly well.</p>"},{"location":"generative/algorithms/","title":"Idea behind this article","text":"<p>Purpose of this article is to gather information and links about ideas and approaches to  algorithmic art. I'm going to use this article as a reference, as an idea source, as a inspiration.</p>"},{"location":"generative/algorithms/#rainbow-smoke","title":"Rainbow Smoke","text":"<p>Very simple idea with stunning results. All is described here: http://rainbowsmoke.hu/home Also, i find this youtube really useful: smoking</p> <p>Possible directions</p> <ul> <li>Change colorspace size/content (e.g. CMYK)</li> <li>Use other painting (Rembrandt?) as source for palette</li> <li>Use approach to change other params - for example, flow fields to determine direction of next pixel</li> <li>Scroll through colorspace (x/y/z) to create animation</li> </ul>"},{"location":"generative/algorithms/#packing-on-plain-surface","title":"Packing on plain surface","text":"<p>Idea first appeared to me when i thought of generative city in ortho projection, like in this insta I need a way to pack obkects on surface, 2d or 3d. For city 2d s fine, i can play later with height of buildings.</p> <p>So most wonderful way i found is this one.</p> <p>This is example of 2d figures filled with this approach.</p> <p>One issue which is essential for this algorithm is how to get intersection. For Blender, i found BHVTree approach is fine but really slow, expectially for 100+ objects. For python 2d i found great library shapely, which can be used to solve this issue.</p> <pre><code>TODO\n</code></pre>"},{"location":"generative/algorithms/#links-and-other-ideas","title":"Links and other ideas","text":"<ol> <li>Wow! Tons of articels in Bridges Archive</li> </ol>"},{"location":"generative/inspiration/","title":"Insta","text":"<ul> <li>idflood</li> </ul>"},{"location":"generative/inspiration/#twitter","title":"Twitter","text":"<ul> <li>Sumruv1</li> </ul>"},{"location":"generative/shaders/","title":"Shaders","text":"<p>This will describe my experience with shaders.</p> <p>Main reason why i'm interested in this - i need something to use as background for my music. I love generative art, so to me shaders seem to be pure generative art...</p> <p>``` https://www.shadertoy.com/new</p> <p>https://www.youtube.com/watch?v=f4s1h2YETNY</p> <p>https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Basic_types</p> <p>https://graphtoy.com/</p> <p>https://iquilezles.org/articles/distfunctions2d/</p> <p>https://iquilezles.org/articles/palettes/</p> <p>http://dev.thi.ng/gradients/</p> <p>https://rijnieks.com/workshops/ffmpeg-shadertoy/?fbclid=IwAR0DkIfMbSedt5HTVDfICF9PHlTp-_-9-vGzZqpStBSHlnw8pf-dJ4g6__o```</p>"},{"location":"generative/shaders/#links","title":"Links","text":"<p>https://iquilezles.org/articles/</p> <p>https://thebookofshaders.com/</p>"}]}